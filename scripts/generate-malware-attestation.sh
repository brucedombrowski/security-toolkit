#!/bin/bash
#
# Malware Scan Attestation PDF Generator
#
# Purpose: Generate PDF attestation document from malware scan results
# Usage: ./generate-malware-attestation.sh <scans_dir> [malware_scan_file]
#
# Required arguments:
#   scans_dir           Path to .scans directory containing scan results
#
# Optional arguments:
#   malware_scan_file   Specific malware scan file (defaults to most recent)
#
# Environment variables (optional, auto-detected if not set):
#   TARGET_NAME         Name to display (defaults to scan target directory)
#   SCAN_SCOPE          Scope description (e.g., "Local Scan", "Remote Scan")
#   TOOLKIT_VERSION     Version of security toolkit
#   TOOLKIT_COMMIT      Git commit hash of toolkit
#
# Exit codes:
#   0 = PDF generated successfully
#   1 = PDF generation failed
#   2 = Missing dependencies or arguments
#

set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECURITY_REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check arguments
if [ -z "${1:-}" ]; then
    echo "Usage: $0 <scans_dir> [malware_scan_file]" >&2
    echo "  scans_dir:         Path to .scans directory containing scan results" >&2
    echo "  malware_scan_file: Specific malware scan file (optional)" >&2
    exit 2
fi

SCANS_DIR="$1"
MALWARE_SCAN_FILE="${2:-}"

# Verify scans directory exists
if [ ! -d "$SCANS_DIR" ]; then
    echo "Error: Scans directory not found: $SCANS_DIR" >&2
    exit 2
fi

# Convert to absolute path
SCANS_DIR="$(cd "$SCANS_DIR" && pwd)"

# Find malware scan file
if [ -z "$MALWARE_SCAN_FILE" ]; then
    # Find most recent malware scan file
    MALWARE_SCAN_FILE=$(ls -t "$SCANS_DIR"/malware-scan-*.txt "$SCANS_DIR"/remote-malware-*.txt 2>/dev/null | head -1)
fi

if [ -z "$MALWARE_SCAN_FILE" ] || [ ! -f "$MALWARE_SCAN_FILE" ]; then
    echo "Error: No malware scan file found in $SCANS_DIR" >&2
    exit 2
fi

echo "Generating malware attestation PDF..."
echo "  Source: $(basename "$MALWARE_SCAN_FILE")"

# Check for pdflatex
PDFLATEX=$(which pdflatex 2>/dev/null || echo "")
if [ -z "$PDFLATEX" ] || [ ! -x "$PDFLATEX" ]; then
    echo "Warning: pdflatex not found, PDF generation skipped"
    echo "         Install with: brew install basictex (macOS) or apt install texlive-latex-base (Linux)"
    exit 2
fi

# Check for template
TEMPLATE_FILE="$SECURITY_REPO_DIR/templates/malware_attestation.tex"
if [ ! -f "$TEMPLATE_FILE" ]; then
    echo "Error: Template not found at $TEMPLATE_FILE" >&2
    exit 1
fi

# Function to escape LaTeX special characters
escape_latex_chars() {
    local input="$1"
    echo "$input" | \
        sed 's/\\/\\textbackslash{}/g' | \
        sed 's/\$/\\$/g' | \
        sed 's/_/\\_/g' | \
        sed 's/{/\\{/g' | \
        sed 's/}/\\}/g' | \
        sed 's/&/\\&/g' | \
        sed 's/%/\\%/g' | \
        sed 's/#/\\#/g' | \
        sed 's/\^/\\textasciicircum{}/g' | \
        sed 's/~/\\textasciitilde{}/g'
}

# ============================================================================
# PARSE MALWARE SCAN OUTPUT
# ============================================================================

# Calculate checksum of source file
SOURCE_FILE_CHECKSUM=$(shasum -a 256 "$MALWARE_SCAN_FILE" 2>/dev/null | awk '{print $1}')
SOURCE_FILE_BASENAME=$(basename "$MALWARE_SCAN_FILE")

# Extract scan timestamp from file
SCAN_TIMESTAMP=$(grep -E "^Timestamp:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Timestamp: //' || echo "Unknown")

# Extract toolkit info
TOOLKIT_INFO=$(grep -E "^Toolkit:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 || echo "")
TOOLKIT_VERSION="${TOOLKIT_VERSION:-$(echo "$TOOLKIT_INFO" | sed -E 's/.*v([0-9]+\.[0-9]+\.[0-9]+).*/v\1/' || echo "Unknown")}"
TOOLKIT_COMMIT="${TOOLKIT_COMMIT:-$(echo "$TOOLKIT_INFO" | sed -E 's/.*\(([a-f0-9]+)\).*/\1/' || echo "Unknown")}"

# Extract ClamAV version
CLAMAV_VERSION=$(grep -E "^Scanner:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Scanner: //' || echo "ClamAV Unknown")

# Parse ClamAV version string for details (format: ClamAV X.X.X/DBVER/DATE)
VIRUS_DB_VERSION=$(echo "$CLAMAV_VERSION" | sed -E 's|.*/([0-9]+)/.*|\1|' || echo "Unknown")
VIRUS_DB_DATE=$(echo "$CLAMAV_VERSION" | sed -E 's|.*/[0-9]+/(.*)|\1|' || echo "Unknown")

# Extract signature count from database info
SIGNATURE_COUNT=$(grep -E "signatures\)" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed -E 's/.*\(([0-9]+) signatures\).*/\1/' || echo "Unknown")
if [ "$SIGNATURE_COUNT" = "Unknown" ]; then
    # Try alternate format
    SIGNATURE_COUNT=$(grep -E "Known viruses:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Known viruses: //' || echo "Unknown")
fi

# Extract scan target
SCAN_TARGET=$(grep -E "^Target:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Target: //' || echo "Unknown")

# Determine if remote or local scan and format target path
if [[ "$SOURCE_FILE_BASENAME" == remote-* ]]; then
    IS_REMOTE=true
    DEFAULT_SCOPE="Remote Scan"
    HOST_INFO=$(grep -E "^Host:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Host: //' || echo "")
    if [ -n "$HOST_INFO" ]; then
        DEFAULT_SCOPE="Remote Scan: $HOST_INFO"
    fi
    # Prefix target path with (remote)
    SCAN_TARGET="(remote) $SCAN_TARGET"
else
    IS_REMOTE=false
    DEFAULT_SCOPE="Local Scan"
    # Prefix target path with (local)
    SCAN_TARGET="(local) $SCAN_TARGET"
fi
SCAN_SCOPE="${SCAN_SCOPE:-$DEFAULT_SCOPE}"

# ============================================================================
# MACHINE IDENTIFICATION
# Generate identifiers for both Scan Machine and Target Machine
# ============================================================================

# Helper function to generate machine fingerprint
# Works on macOS, Linux, and Windows (Git Bash/MSYS)
# Sets global variables: MACHINE_FINGERPRINT, FINGERPRINT_INTERFACE, FINGERPRINT_METHOD
generate_machine_fingerprint() {
    local mac=""
    local interface=""
    local hostname=$(hostname 2>/dev/null || echo "unknown")

    case "$(uname -s)" in
        Darwin)
            # macOS: try en0 first (usually Wi-Fi or Ethernet), then any active interface
            if ifconfig en0 &>/dev/null; then
                mac=$(ifconfig en0 2>/dev/null | grep ether | awk '{print $2}')
                if [ -n "$mac" ]; then
                    interface="en0"
                fi
            fi
            if [ -z "$mac" ]; then
                # Find first active interface
                for iface in $(ifconfig -l 2>/dev/null); do
                    if ifconfig "$iface" 2>/dev/null | grep -q "status: active"; then
                        mac=$(ifconfig "$iface" 2>/dev/null | grep ether | awk '{print $2}')
                        if [ -n "$mac" ]; then
                            interface="$iface"
                            break
                        fi
                    fi
                done
            fi
            ;;
        Linux)
            # Linux: get first non-loopback MAC with state UP
            interface=$(ip link show 2>/dev/null | grep "state UP" | head -1 | awk -F: '{print $2}' | tr -d ' ')
            if [ -n "$interface" ]; then
                mac=$(ip link show "$interface" 2>/dev/null | grep link/ether | awk '{print $2}')
            fi
            if [ -z "$mac" ]; then
                # Fallback: try ifconfig on older systems
                mac=$(ifconfig 2>/dev/null | grep -o -E '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}' | head -1)
                interface="unknown"
            fi
            ;;
        MINGW*|MSYS*|CYGWIN*)
            # Windows (Git Bash, MSYS, Cygwin): use getmac or ipconfig
            if command -v getmac &>/dev/null; then
                # getmac returns "MAC,Transport,Interface" - get interface name too
                local getmac_line=$(getmac /fo csv /nh 2>/dev/null | head -1)
                mac=$(echo "$getmac_line" | cut -d',' -f1 | tr -d '"')
                interface=$(echo "$getmac_line" | cut -d',' -f3 | tr -d '"' | sed 's/\\Device\\Tcpip_//')
            elif command -v ipconfig &>/dev/null; then
                mac=$(ipconfig /all 2>/dev/null | grep -i "Physical Address" | head -1 | sed 's/.*: //' | tr -d '-')
                interface="primary"
            fi
            ;;
    esac

    # Generate fingerprint: SHA256 of MAC:hostname (first 16 chars)
    # If no MAC available, use hostname + OS info as fallback
    if [ -n "$mac" ]; then
        MACHINE_FINGERPRINT=$(echo -n "${mac}:${hostname}" | shasum -a 256 | awk '{print substr($1,1,16)}')
        FINGERPRINT_INTERFACE="${interface:-unknown}"
        FINGERPRINT_METHOD="SHA256(MAC[$FINGERPRINT_INTERFACE]:hostname)[0:16]"
    else
        # Fallback: hostname + uname (less unique but still useful)
        local os_info=$(uname -s 2>/dev/null || echo "unknown")
        MACHINE_FINGERPRINT=$(echo -n "${hostname}:${os_info}" | shasum -a 256 | awk '{print substr($1,1,16)}')
        FINGERPRINT_INTERFACE="none"
        FINGERPRINT_METHOD="SHA256(hostname:os)[0:16]"
    fi
}

# --- SCAN MACHINE (always the local machine running the toolkit) ---
generate_machine_fingerprint
SCAN_MACHINE_ID="$MACHINE_FINGERPRINT"
SCAN_MACHINE_ID_TYPE="Fingerprint"
SCAN_MACHINE_ID_METHOD="$FINGERPRINT_METHOD"

# --- TARGET MACHINE (depends on local vs remote scan) ---
TARGET_MACHINE_ID=""
TARGET_MACHINE_ID_TYPE=""
TARGET_MACHINE_ID_METHOD=""
TARGET_INVENTORY_FILE="N/A"

# Check if this is a remote scan
if [[ "$SOURCE_FILE_BASENAME" == remote-* ]]; then
    # Remote scan - target is different machine
    # Look for remote inventory file
    REMOTE_INVENTORY=$(ls -t "$SCANS_DIR"/remote-inventory-*.txt 2>/dev/null | head -1)

    if [ -n "$REMOTE_INVENTORY" ] && [ -f "$REMOTE_INVENTORY" ]; then
        TARGET_INVENTORY_FILE=$(basename "$REMOTE_INVENTORY")
        # Use inventory checksum as identifier (first 16 chars)
        TARGET_MACHINE_ID=$(shasum -a 256 "$REMOTE_INVENTORY" 2>/dev/null | awk '{print substr($1,1,16)}')
        TARGET_MACHINE_ID_TYPE="Inventory Hash"
        TARGET_MACHINE_ID_METHOD="SHA256(inventory)[0:16]"

        # Try to extract hostname from inventory for TARGET_NAME
        INVENTORY_HOSTNAME=$(grep -E "^Hostname:|^  Hostname:" "$REMOTE_INVENTORY" 2>/dev/null | head -1 | sed 's/.*Hostname: //' || echo "")
    else
        # No inventory - use host from scan file
        REMOTE_HOST=$(grep -E "^Host:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/Host: //' || echo "remote")
        TARGET_MACHINE_ID=$(echo -n "$REMOTE_HOST" | shasum -a 256 | awk '{print substr($1,1,16)}')
        TARGET_MACHINE_ID_TYPE="Host Hash"
        TARGET_MACHINE_ID_METHOD="SHA256(hostname)[0:16]"
    fi
else
    # Local scan - target is same as scan machine
    TARGET_MACHINE_ID="$SCAN_MACHINE_ID"
    TARGET_MACHINE_ID_TYPE="$SCAN_MACHINE_ID_TYPE (same as scan machine)"
    TARGET_MACHINE_ID_METHOD="$SCAN_MACHINE_ID_METHOD"

    # Look for local host inventory
    LOCAL_INVENTORY=$(ls -t "$SCANS_DIR"/host-inventory-*.txt 2>/dev/null | head -1)
    if [ -n "$LOCAL_INVENTORY" ] && [ -f "$LOCAL_INVENTORY" ]; then
        TARGET_INVENTORY_FILE=$(basename "$LOCAL_INVENTORY")
        INVENTORY_HOSTNAME=$(grep -E "^Hostname:" "$LOCAL_INVENTORY" 2>/dev/null | head -1 | sed 's/Hostname: //' || echo "")
    fi
fi

# Build TARGET_NAME for header
if [ -n "${TARGET_NAME:-}" ]; then
    # User provided explicit target name
    :
elif [ -n "${INVENTORY_HOSTNAME:-}" ]; then
    # Use hostname from inventory
    TARGET_NAME="$INVENTORY_HOSTNAME"
else
    # Use fingerprint-based identifier
    TARGET_NAME="Host:$TARGET_MACHINE_ID"
fi

# Extract scan statistics - check both main file and ClamAV log
# First try the main scan file, then fall back to ClamAV log
CLAMAV_LOG=""
CLAMAV_LOG_REF=$(grep "ClamAV Log:" "$MALWARE_SCAN_FILE" 2>/dev/null | sed 's/.*ClamAV Log: //')
if [ -n "$CLAMAV_LOG_REF" ] && [ -f "$CLAMAV_LOG_REF" ]; then
    CLAMAV_LOG="$CLAMAV_LOG_REF"
else
    # Try to find ClamAV log in same directory
    CLAMAV_LOG=$(ls -t "$SCANS_DIR"/clamav-log-*.txt 2>/dev/null | head -1)
fi

# Parse statistics from ClamAV log (preferred) or main file
if [ -n "$CLAMAV_LOG" ] && [ -f "$CLAMAV_LOG" ]; then
    INFECTED_COUNT=$(grep -E "^Infected files:" "$CLAMAV_LOG" 2>/dev/null | sed 's/Infected files: //' || echo "0")
    SCANNED_FILES=$(grep -E "^Scanned files:" "$CLAMAV_LOG" 2>/dev/null | sed 's/Scanned files: //' || echo "Unknown")
    SCANNED_DIRS=$(grep -E "^Scanned directories:" "$CLAMAV_LOG" 2>/dev/null | sed 's/Scanned directories: //' || echo "Unknown")
    DATA_SCANNED=$(grep -E "^Data scanned:" "$CLAMAV_LOG" 2>/dev/null | sed 's/Data scanned: //' || echo "Unknown")
    SCAN_TIME=$(grep -E "^Time:" "$CLAMAV_LOG" 2>/dev/null | sed 's/Time: //' || echo "Unknown")
else
    # Fallback to main scan file
    INFECTED_COUNT=$(grep -E "^Infected files:" "$MALWARE_SCAN_FILE" 2>/dev/null | tail -1 | sed 's/Infected files: //' || echo "0")
    SCANNED_FILES=$(grep -E "^Scanned files:" "$MALWARE_SCAN_FILE" 2>/dev/null | tail -1 | sed 's/Scanned files: //' || echo "Unknown")
    SCANNED_DIRS=$(grep -E "^Scanned directories:" "$MALWARE_SCAN_FILE" 2>/dev/null | tail -1 | sed 's/Scanned directories: //' || echo "Unknown")
    DATA_SCANNED=$(grep -E "^Data scanned:" "$MALWARE_SCAN_FILE" 2>/dev/null | tail -1 | sed 's/Data scanned: //' || echo "Unknown")
    SCAN_TIME=$(grep -E "^Time:" "$MALWARE_SCAN_FILE" 2>/dev/null | tail -1 | sed 's/Time: //' || echo "Unknown")
fi

# Handle empty values
[ -z "$INFECTED_COUNT" ] && INFECTED_COUNT="0"
[ -z "$SCANNED_FILES" ] && SCANNED_FILES="Unknown"
[ -z "$SCANNED_DIRS" ] && SCANNED_DIRS="Unknown"
[ -z "$DATA_SCANNED" ] && DATA_SCANNED="Unknown"
[ -z "$SCAN_TIME" ] && SCAN_TIME="Unknown"

# Determine scan result
SCAN_RESULT=$(grep -E "^RESULT:" "$MALWARE_SCAN_FILE" 2>/dev/null | head -1 | sed 's/RESULT: //' || echo "Unknown")
if [ "$SCAN_RESULT" = "Unknown" ]; then
    # Fallback: check infected count
    if [ "$INFECTED_COUNT" = "0" ]; then
        SCAN_RESULT="PASS"
    else
        SCAN_RESULT="FAIL"
    fi
fi

# ============================================================================
# EXTRACT FILE HASHES FOR APPENDIX
# ============================================================================

# Create temp directory for LaTeX build
PDF_BUILD_DIR=$(mktemp -d)

# Generate file hashes appendix
FILE_HASHES_TEX="$PDF_BUILD_DIR/file_hashes.tex"

{
    # Check if we have hash data in the scan file
    if grep -q "SHA256:" "$MALWARE_SCAN_FILE" 2>/dev/null; then
        # Use lstlisting environment which handles special chars naturally
        echo '\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,breaklines=true,columns=fullflexible]'
        echo 'FILE                                          SHA256'
        echo '============================================  ================================================================'

        # Parse file hash entries from scan output
        current_file=""
        current_hash=""
        line_count=0
        max_files=1000  # Limit for very large scans

        while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]{2}[A-Za-z] ]]; then
                # This is a file entry (starts with 2 spaces and letter)
                current_file=$(echo "$line" | sed 's/^[[:space:]]*//')
            elif [[ "$line" =~ "SHA256:" ]]; then
                current_hash=$(echo "$line" | sed 's/.*SHA256: //')
                if [ -n "$current_file" ] && [ -n "$current_hash" ]; then
                    # Truncate long filenames
                    display_file="$current_file"
                    if [ ${#display_file} -gt 42 ]; then
                        display_file="...${display_file: -39}"
                    fi
                    # Pad filename to 44 chars for alignment
                    printf '%-44s  %s\n' "$display_file" "$current_hash"
                    line_count=$((line_count + 1))
                    if [ $line_count -ge $max_files ]; then
                        echo ""
                        printf '... truncated (showing first %d files)\n' "$max_files"
                        break
                    fi
                    current_file=""
                fi
            fi
        done < "$MALWARE_SCAN_FILE"

        echo '\end{lstlisting}'

        if [ $line_count -eq 0 ]; then
            echo '\textbf{No file hashes available in scan output.}'
            echo ''
            echo 'File hashes are generated when ClamAV supports the --gen-json option.'
        else
            printf '\n\\vspace{6pt}\n'
            printf '\\textbf{Files shown:} %d' "$line_count"
            if [ $line_count -ge $max_files ]; then
                printf ' (limited for document size)\n\n'
                printf '\\textbf{Complete hash list:} See source file \\texttt{%s}\n' "$SOURCE_FILE_BASENAME"
            else
                printf '\n'
            fi
        fi
    else
        # No hash data - show message
        echo '\textbf{No file hashes available in scan output.}'
        echo ''
        echo 'This may occur when:'
        echo '\begin{itemize}'
        echo '    \item ClamAV version does not support --gen-json'
        echo '    \item Scan was run with reduced output'
        echo '    \item Remote scan without hash collection'
        echo '\end{itemize}'
        echo ''
        echo 'The ClamAV log file contains detailed scan results.'
    fi
} > "$FILE_HASHES_TEX"

# ============================================================================
# BUILD PDF
# ============================================================================

# Generate unique ID
UNIQUE_ID="MAL-$(date -u +%Y%m%d-%H%M%S)"
FORMATTED_DATE=$(date "+%B %d, %Y")

# Extract timestamp from filename for output naming
FILE_TIMESTAMP=$(echo "$SOURCE_FILE_BASENAME" | sed -E 's/.*-([0-9]{4}-[0-9]{2}-[0-9]{2}.*).txt/\1/' || echo "$(date +%Y-%m-%d)")

# Copy template
cp "$TEMPLATE_FILE" "$PDF_BUILD_DIR/malware_attestation.tex"

# Copy logo if available
if [ -f "$SECURITY_REPO_DIR/templates/logo.png" ]; then
    cp "$SECURITY_REPO_DIR/templates/logo.png" "$PDF_BUILD_DIR/"
fi

# Escape all variables for LaTeX
UNIQUE_ID_ESC=$(escape_latex_chars "$UNIQUE_ID")
FORMATTED_DATE_ESC=$(escape_latex_chars "$FORMATTED_DATE")
SCAN_TIMESTAMP_ESC=$(escape_latex_chars "$SCAN_TIMESTAMP")
TARGET_NAME_ESC=$(escape_latex_chars "$TARGET_NAME")
SCAN_SCOPE_ESC=$(escape_latex_chars "$SCAN_SCOPE")
SCAN_TARGET_ESC=$(escape_latex_chars "$SCAN_TARGET")
TOOLKIT_VERSION_ESC=$(escape_latex_chars "$TOOLKIT_VERSION")
TOOLKIT_COMMIT_ESC=$(escape_latex_chars "$TOOLKIT_COMMIT")
CLAMAV_VERSION_ESC=$(escape_latex_chars "$CLAMAV_VERSION")
VIRUS_DB_VERSION_ESC=$(escape_latex_chars "$VIRUS_DB_VERSION")
VIRUS_DB_DATE_ESC=$(escape_latex_chars "$VIRUS_DB_DATE")
SIGNATURE_COUNT_ESC=$(escape_latex_chars "$SIGNATURE_COUNT")
SCAN_RESULT_ESC=$(escape_latex_chars "$SCAN_RESULT")
INFECTED_COUNT_ESC=$(escape_latex_chars "$INFECTED_COUNT")
SCANNED_FILES_ESC=$(escape_latex_chars "$SCANNED_FILES")
SCANNED_DIRS_ESC=$(escape_latex_chars "$SCANNED_DIRS")
DATA_SCANNED_ESC=$(escape_latex_chars "$DATA_SCANNED")
SCAN_TIME_ESC=$(escape_latex_chars "$SCAN_TIME")
SOURCE_FILE_BASENAME_ESC=$(escape_latex_chars "$SOURCE_FILE_BASENAME")
SOURCE_FILE_CHECKSUM_ESC=$(escape_latex_chars "$SOURCE_FILE_CHECKSUM")

# Escape machine identification variables
SCAN_MACHINE_ID_ESC=$(escape_latex_chars "$SCAN_MACHINE_ID")
SCAN_MACHINE_ID_TYPE_ESC=$(escape_latex_chars "$SCAN_MACHINE_ID_TYPE")
SCAN_MACHINE_ID_METHOD_ESC=$(escape_latex_chars "$SCAN_MACHINE_ID_METHOD")
TARGET_MACHINE_ID_ESC=$(escape_latex_chars "$TARGET_MACHINE_ID")
TARGET_MACHINE_ID_TYPE_ESC=$(escape_latex_chars "$TARGET_MACHINE_ID_TYPE")
TARGET_MACHINE_ID_METHOD_ESC=$(escape_latex_chars "$TARGET_MACHINE_ID_METHOD")
TARGET_INVENTORY_FILE_ESC=$(escape_latex_chars "$TARGET_INVENTORY_FILE")

# Escape forward slashes in ClamAV version for sed
CLAMAV_VERSION_SED=$(echo "$CLAMAV_VERSION_ESC" | sed 's|/|\\/|g')

# Perform substitutions
sed -i.bak \
    -e "s/MAL-YYYY-NNN/$UNIQUE_ID_ESC/g" \
    -e "s/January 15, 2026/$FORMATTED_DATE_ESC/g" \
    -e "s/2026-01-15 08:00:00/$SCAN_TIMESTAMP_ESC/g" \
    -e "s/ProjectName/$TARGET_NAME_ESC/g" \
    -e "s/Local Scan/$SCAN_SCOPE_ESC/g" \
    -e "s|/path/to/target|$SCAN_TARGET_ESC|g" \
    -e "s/v1.0.0/$TOOLKIT_VERSION_ESC/g" \
    -e "s/abc1234/$TOOLKIT_COMMIT_ESC/g" \
    -e "s/ClamAV 1.0.0/$CLAMAV_VERSION_SED/g" \
    -e "s/\\\\newcommand{\\\\VirusDBVersion}{27000}/\\\\newcommand{\\\\VirusDBVersion}{$VIRUS_DB_VERSION_ESC}/g" \
    -e "s/\\\\newcommand{\\\\VirusDBDate}{Jan 01, 2026}/\\\\newcommand{\\\\VirusDBDate}{$VIRUS_DB_DATE_ESC}/g" \
    -e "s/\\\\newcommand{\\\\SignatureCount}{3000000}/\\\\newcommand{\\\\SignatureCount}{$SIGNATURE_COUNT_ESC}/g" \
    -e "s/\\\\newcommand{\\\\ScanResult}{PASS}/\\\\newcommand{\\\\ScanResult}{$SCAN_RESULT_ESC}/g" \
    -e "s/\\\\newcommand{\\\\InfectedCount}{0}/\\\\newcommand{\\\\InfectedCount}{$INFECTED_COUNT_ESC}/g" \
    -e "s/\\\\newcommand{\\\\ScannedFilesCount}{100}/\\\\newcommand{\\\\ScannedFilesCount}{$SCANNED_FILES_ESC}/g" \
    -e "s/\\\\newcommand{\\\\ScannedDirsCount}{10}/\\\\newcommand{\\\\ScannedDirsCount}{$SCANNED_DIRS_ESC}/g" \
    -e "s/\\\\newcommand{\\\\DataScanned}{10.5 MiB}/\\\\newcommand{\\\\DataScanned}{$DATA_SCANNED_ESC}/g" \
    -e "s/\\\\newcommand{\\\\ScanDuration}{5.2 sec}/\\\\newcommand{\\\\ScanDuration}{$SCAN_TIME_ESC}/g" \
    -e "s/malware-scan-2026-01-15.txt/$SOURCE_FILE_BASENAME_ESC/g" \
    -e "s/\\\\newcommand{\\\\SourceFileChecksum}{0000000000000000000000000000000000000000000000000000000000000000}/\\\\newcommand{\\\\SourceFileChecksum}{$SOURCE_FILE_CHECKSUM_ESC}/g" \
    -e "s|\\\\newcommand{\\\\ScanMachineID}{N/A}|\\\\newcommand{\\\\ScanMachineID}{$SCAN_MACHINE_ID_ESC}|g" \
    -e "s|\\\\newcommand{\\\\ScanMachineIDType}{Fingerprint}|\\\\newcommand{\\\\ScanMachineIDType}{$SCAN_MACHINE_ID_TYPE_ESC}|g" \
    -e "s|\\\\newcommand{\\\\ScanMachineIDMethod}{SHA256(MAC:hostname)}|\\\\newcommand{\\\\ScanMachineIDMethod}{$SCAN_MACHINE_ID_METHOD_ESC}|g" \
    -e "s|\\\\newcommand{\\\\TargetMachineID}{N/A}|\\\\newcommand{\\\\TargetMachineID}{$TARGET_MACHINE_ID_ESC}|g" \
    -e "s|\\\\newcommand{\\\\TargetMachineIDType}{Fingerprint}|\\\\newcommand{\\\\TargetMachineIDType}{$TARGET_MACHINE_ID_TYPE_ESC}|g" \
    -e "s|\\\\newcommand{\\\\TargetMachineIDMethod}{SHA256(MAC:hostname)}|\\\\newcommand{\\\\TargetMachineIDMethod}{$TARGET_MACHINE_ID_METHOD_ESC}|g" \
    -e "s|\\\\newcommand{\\\\TargetInventoryFile}{N/A}|\\\\newcommand{\\\\TargetInventoryFile}{$TARGET_INVENTORY_FILE_ESC}|g" \
    "$PDF_BUILD_DIR/malware_attestation.tex"

# Run pdflatex
cd "$PDF_BUILD_DIR"
PDFLATEX_LOG="$PDF_BUILD_DIR/pdflatex.log"

$PDFLATEX -interaction=nonstopmode malware_attestation.tex > "$PDFLATEX_LOG" 2>&1 || true
$PDFLATEX -interaction=nonstopmode malware_attestation.tex > /dev/null 2>&1 || true

# Check result and copy output
EXIT_CODE=0
if [ -f "malware_attestation.pdf" ]; then
    OUTPUT_PDF="$SCANS_DIR/malware-attestation-$FILE_TIMESTAMP.pdf"
    cp "malware_attestation.pdf" "$OUTPUT_PDF"
    echo "  Output: $(basename "$OUTPUT_PDF")"
    echo ""
    echo "Malware attestation PDF generated successfully."
else
    echo "  PDF generation failed"
    echo ""
    if [ -f "$PDFLATEX_LOG" ]; then
        echo "  pdflatex errors:"
        tail -20 "$PDFLATEX_LOG" | while read -r line; do
            echo "    $line"
        done
    fi
    EXIT_CODE=1
fi

# Cleanup
rm -rf "$PDF_BUILD_DIR"

exit $EXIT_CODE
