#!/bin/bash
#
# PII Verification Script
#
# Purpose: Automated scanning of repository files for potential PII patterns
# Method: Pattern matching using grep with regex
#
# Patterns checked:
#   - IP addresses (IPv4)
#   - Phone numbers (US formats)
#   - Social Security Numbers
#   - Credit Card Numbers
#
# Exit codes:
#   0 = All checks passed (no PII found, or all reviewed/accepted)
#   1 = Potential PII detected (requires review)
#
# Usage: ./check-pii.sh [-i] [target_directory]
#        -i  Interactive mode: prompt to accept/reject each finding
#        If no target specified, uses parent directory of script location
#
# Allowlist:
#   Accepted findings are stored in <target>/.pii-allowlist
#   Format: SHA256 hash of "file:line:content" per line
#   Allowlisted items are automatically skipped in future scans

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECURITY_REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse arguments
INTERACTIVE=0
TARGET_DIR=""

while [ $# -gt 0 ]; do
    case "$1" in
        -i|--interactive)
            INTERACTIVE=1
            shift
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR="$SECURITY_REPO_DIR"
fi

# Allowlist file location
ALLOWLIST_FILE="$TARGET_DIR/.pii-allowlist"

# Use UTC for consistent timestamps across time zones
TIMESTAMP=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
REPO_NAME=$(basename "$TARGET_DIR")
TOOLKIT_VERSION=$(git -C "$SECURITY_REPO_DIR" describe --tags --always 2>/dev/null || echo "unknown")
TOOLKIT_COMMIT=$(git -C "$SECURITY_REPO_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Files to scan (common text file types)
INCLUDE_PATTERNS=(
    "*.md" "*.txt" "*.tex" "*.rst"
    "*.sh" "*.bash" "*.zsh"
    "*.py" "*.js" "*.ts" "*.rb" "*.php" "*.go" "*.rs" "*.java" "*.cs" "*.c" "*.cpp" "*.h"
    "*.yaml" "*.yml" "*.json" "*.xml" "*.toml" "*.ini" "*.conf" "*.config"
    "*.html" "*.css" "*.scss"
    "*.sql"
    "*.env" "*.env.example"
)

FOUND_ISSUES=0
REVIEW_COUNT=0
ACCEPTED_COUNT=0
REJECTED_COUNT=0

# Function to compute hash for a finding (used for allowlist)
hash_finding() {
    echo -n "$1" | shasum -a 256 | awk '{print $1}'
}

# Function to check if a finding is allowlisted
is_allowlisted() {
    local finding="$1"
    local hash=$(hash_finding "$finding")
    if [ -f "$ALLOWLIST_FILE" ]; then
        grep -q "^$hash" "$ALLOWLIST_FILE" 2>/dev/null && return 0
    fi
    return 1
}

# Function to add a finding to the allowlist
add_to_allowlist() {
    local finding="$1"
    local reason="$2"
    local hash=$(hash_finding "$finding")

    # Create allowlist file with header if it doesn't exist
    if [ ! -f "$ALLOWLIST_FILE" ]; then
        {
            echo "# PII Scan Allowlist"
            echo "# Format: SHA256_HASH # REASON # FINDING"
            echo "# Generated by Security Verification Toolkit"
            echo ""
        } > "$ALLOWLIST_FILE"
    fi

    # Add entry with hash, reason, and truncated finding for reference
    local truncated=$(echo "$finding" | cut -c1-80)
    echo "$hash # $reason # $truncated" >> "$ALLOWLIST_FILE"
}

# Function to prompt user for interactive review
prompt_review() {
    local finding="$1"
    local check_name="$2"

    # Parse the finding to extract file, line, and content
    local file_path=$(echo "$finding" | cut -d: -f1)
    local line_num=$(echo "$finding" | cut -d: -f2)
    local content=$(echo "$finding" | cut -d: -f3-)

    # Get relative path for cleaner display
    local rel_path="${file_path#$TARGET_DIR/}"

    echo ""
    echo "  ┌─────────────────────────────────────────────────────────────────"
    echo "  │ REVIEW REQUIRED: $check_name"
    echo "  ├─────────────────────────────────────────────────────────────────"
    echo "  │ File: $rel_path"
    echo "  │ Line: $line_num"
    echo "  │"
    echo "  │ Content:"
    echo "  │   $content"
    echo "  └─────────────────────────────────────────────────────────────────"
    echo ""

    # Provide context-aware explanation based on content
    if echo "$content" | grep -qE "1\.3\.6\.1\.[0-9]"; then
        echo "  WHY THIS MATCHED:"
        echo "    This is an X.509 Object Identifier (OID), not an IP address."
        echo "    OIDs identify certificate purposes (Extended Key Usage)."
        echo "    Code uses these OIDs to filter certificates by purpose"
        echo "    (e.g., selecting only signing or encryption certificates)."
        echo "    Example: 1.3.6.1.5.5.7.3.4 = Email Protection EKU"
        echo ""
    elif echo "$content" | grep -qE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | grep -qvE "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$"; then
        echo "  WHY THIS MATCHED:"
        echo "    This appears to be a version number (e.g., 6.0.0.0), not an IP address."
        echo "    Version strings use similar dot notation but identify software releases."
        echo ""
    elif echo "$content" | grep -q "127\.0\.0\.1"; then
        echo "  WHY THIS MATCHED:"
        echo "    This is localhost (127.0.0.1) - the loopback address."
        echo "    It's commonly used in code to filter out local connections."
        echo "    This is NOT sensitive PII as it refers to the local machine, not a person."
        echo ""
    else
        echo "  WHY THIS MATCHED:"
        echo "    The pattern [0-9].[0-9].[0-9].[0-9] matches IPv4 address format."
        echo "    If this is actually an IP address, it could identify network infrastructure."
        echo "    Common false positives: OIDs, version numbers, file paths with numbers."
        echo ""
    fi

    echo "  OPTIONS:"
    echo "    [A]ccept  - This is NOT PII. Add to allowlist (custom reason)."
    echo "    [R]eject  - This IS PII or needs remediation. Flag as issue."
    echo "    [S]kip    - Unsure. Leave for later review."
    echo ""
    echo "  QUICK ACCEPT (common false positives):"
    echo "    [E]xample - Example/placeholder data (example.com, 192.0.2.x, etc.)"
    echo "    [O]ID     - X.509 Object Identifier (certificate EKU, etc.)"
    echo "    [V]ersion - Version number (e.g., 6.0.0.0)"
    echo "    [L]ocalhost - Loopback address (127.0.0.1)"
    echo "    [D]ocumentation - Documentation or comments"
    echo ""

    while true; do
        echo -n "  Your decision [A/R/S/E/O/V/L/D]: "
        read -r response < /dev/tty
        case "$response" in
            [Ee]*)
                add_to_allowlist "$finding" "Example/placeholder data (not real PII)"
                echo "  → Added to allowlist: Example data"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Oo]*)
                add_to_allowlist "$finding" "X.509 Object Identifier (OID)"
                echo "  → Added to allowlist: OID"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Vv]*)
                add_to_allowlist "$finding" "Version number string"
                echo "  → Added to allowlist: Version number"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Ll]*)
                add_to_allowlist "$finding" "Localhost/loopback address (127.0.0.1)"
                echo "  → Added to allowlist: Localhost"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Dd]*)
                add_to_allowlist "$finding" "Documentation or pattern explanation"
                echo "  → Added to allowlist: Documentation"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Aa]*)
                echo ""
                echo "  Why is this acceptable? (This will be recorded in the allowlist)"
                echo -n "  Reason: "
                read -r reason < /dev/tty
                if [ -z "$reason" ]; then
                    echo "  ✗ Reason is required for audit trail. Please try again."
                    continue
                fi
                add_to_allowlist "$finding" "$reason"
                echo "  → Added to allowlist"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0  # Accepted - not an issue
                ;;
            [Rr]*)
                echo "  → Flagged as potential PII"
                REJECTED_COUNT=$((REJECTED_COUNT + 1))
                return 1  # Rejected - is an issue
                ;;
            [Ss]*)
                echo "  → Skipped (will require review next time)"
                return 2  # Skipped - still needs review
                ;;
            *)
                echo "  Please enter A, R, S, E, O, V, L, or D"
                ;;
        esac
    done
}

echo "PII Verification Scan"
echo "====================="
echo "Timestamp: $TIMESTAMP"
echo "Toolkit: Security Verification Toolkit $TOOLKIT_VERSION ($TOOLKIT_COMMIT)"
echo "Target: $TARGET_DIR"
echo "Repository: $REPO_NAME"
echo ""

# Build include arguments for grep
INCLUDE_ARGS=""
for pattern in "${INCLUDE_PATTERNS[@]}"; do
    INCLUDE_ARGS="$INCLUDE_ARGS --include=$pattern"
done

# Function to run a check and log results
run_check() {
    local check_name="$1"
    local pattern="$2"
    local description="$3"

    echo "Checking: $check_name"

    # Run grep, capture output
    local results=""
    results=$(grep -r -n -E "$pattern" "$TARGET_DIR" \
        $INCLUDE_ARGS \
        --exclude-dir=".git" \
        --exclude-dir="node_modules" \
        --exclude-dir="venv" \
        --exclude-dir=".venv" \
        --exclude-dir="__pycache__" \
        --exclude-dir=".scans" \
        --exclude-dir="obj" \
        --exclude-dir="bin" \
        --exclude-dir="publish" \
        --exclude="*Scan-Results.md" \
        --exclude="check-*.sh" \
        --exclude=".pii-allowlist" \
        2>/dev/null || true)

    local total_count=0
    local new_count=0
    local allowlisted_count=0
    local issue_count=0

    if [ -n "$results" ]; then
        total_count=$(echo "$results" | wc -l | tr -d ' ')

        # Process each finding
        while IFS= read -r line; do
            if [ -z "$line" ]; then
                continue
            fi

            # Check if already allowlisted
            if is_allowlisted "$line"; then
                allowlisted_count=$((allowlisted_count + 1))
                continue
            fi

            new_count=$((new_count + 1))

            # Interactive mode: prompt for each finding
            if [ "$INTERACTIVE" -eq 1 ]; then
                prompt_review "$line" "$check_name"
                local review_result=$?
                if [ $review_result -eq 1 ]; then
                    # Rejected - counts as an issue
                    issue_count=$((issue_count + 1))
                elif [ $review_result -eq 2 ]; then
                    # Skipped - still needs review
                    issue_count=$((issue_count + 1))
                fi
                # If accepted (0), not counted as issue
            else
                # Non-interactive: show findings
                if [ $new_count -le 10 ]; then
                    echo "$line"
                fi
                issue_count=$((issue_count + 1))
            fi
        done <<< "$results"
    fi

    # Report results
    if [ "$total_count" -eq 0 ]; then
        echo "  Result: PASS (0 matches)"
    elif [ "$new_count" -eq 0 ]; then
        echo "  Result: PASS ($allowlisted_count allowlisted)"
    elif [ "$INTERACTIVE" -eq 1 ]; then
        if [ "$issue_count" -eq 0 ]; then
            echo "  Result: PASS (all $new_count finding(s) accepted)"
        else
            echo "  Result: REVIEW - $issue_count unresolved finding(s)"
            FOUND_ISSUES=1
        fi
    else
        echo "  Result: REVIEW - $new_count new match(es) found"
        if [ "$new_count" -gt 10 ]; then
            echo "  ... and $((new_count - 10)) more"
        fi
        if [ "$allowlisted_count" -gt 0 ]; then
            echo "  ($allowlisted_count previously allowlisted)"
        fi
        FOUND_ISSUES=1
    fi
}

# Run all checks
run_check "IPv4 Addresses" \
    "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" \
    "Searches for IP address patterns that could identify network infrastructure"

run_check "US Phone Numbers (dashed)" \
    "[0-9]{3}[-][0-9]{3}[-][0-9]{4}" \
    "Searches for phone numbers in XXX-XXX-XXXX format"

run_check "US Phone Numbers (dotted)" \
    "[0-9]{3}[.][0-9]{3}[.][0-9]{4}" \
    "Searches for phone numbers in XXX.XXX.XXXX format"

run_check "US Phone Numbers (parenthetical)" \
    "\([0-9]{3}\)[ ]*[0-9]{3}[-. ][0-9]{4}" \
    "Searches for phone numbers in (XXX) XXX-XXXX format"

run_check "Social Security Numbers" \
    "[0-9]{3}-[0-9]{2}-[0-9]{4}" \
    "Searches for SSN patterns in XXX-XX-XXXX format"

run_check "Credit Card Numbers (16 digit)" \
    "[0-9]{4}[-. ]?[0-9]{4}[-. ]?[0-9]{4}[-. ]?[0-9]{4}" \
    "Searches for 16-digit sequences that could be credit card numbers"

# Summary
echo ""
echo "====================="

if [ "$INTERACTIVE" -eq 1 ]; then
    echo "Interactive Review Summary:"
    echo "  Accepted (allowlisted): $ACCEPTED_COUNT"
    echo "  Rejected (flagged):     $REJECTED_COUNT"
    echo ""
fi

if [ -f "$ALLOWLIST_FILE" ]; then
    ALLOWLIST_COUNT=$(grep -c "^[a-f0-9]" "$ALLOWLIST_FILE" 2>/dev/null || echo "0")
    echo "Allowlist: $ALLOWLIST_FILE ($ALLOWLIST_COUNT entries)"
    echo ""
fi

if [ $FOUND_ISSUES -eq 0 ]; then
    echo "OVERALL RESULT: PASS"
    if [ "$INTERACTIVE" -eq 1 ]; then
        echo "All findings reviewed and accepted."
    else
        echo "No PII patterns detected."
    fi
else
    echo "OVERALL RESULT: REVIEW REQUIRED"
    echo "Potential PII patterns detected. Manual review required."
    if [ "$INTERACTIVE" -eq 0 ]; then
        echo ""
        echo "Run with -i flag for interactive review:"
        echo "  $0 -i $TARGET_DIR"
    fi
fi

exit $FOUND_ISSUES
