#!/bin/bash
#
# Secrets/Vulnerability Verification Script
#
# Purpose: Automated scanning for common security vulnerabilities
# Method: Pattern matching for secrets, credentials, and security anti-patterns
#
# Checks performed:
#   - Hardcoded API keys and tokens
#   - AWS/cloud credentials
#   - Private keys
#   - Database connection strings with passwords
#   - Hardcoded passwords in code
#   - GitHub/Slack tokens
#   - Shell command injection patterns
#
# Exit codes:
#   0 = All checks passed (no vulnerabilities found, or all reviewed/accepted)
#   1 = Potential vulnerabilities detected (requires review)
#
# Usage: ./check-secrets.sh [-i] [target_directory]
#        -i  Interactive mode: prompt to accept/reject each finding
#        If no target specified, uses parent directory of script location
#
# Allowlist:
#   Accepted findings are stored in <target>/.secrets-allowlist
#   Format: SHA256 hash of "file:line:content" per line
#   Allowlisted items are automatically skipped in future scans

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECURITY_REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse arguments
INTERACTIVE=0
TARGET_DIR=""

while [ $# -gt 0 ]; do
    case "$1" in
        -i|--interactive)
            INTERACTIVE=1
            shift
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR="$SECURITY_REPO_DIR"
fi

# Allowlist file location
ALLOWLIST_FILE="$TARGET_DIR/.secrets-allowlist"

# Use UTC for consistent timestamps across time zones
TIMESTAMP=$(date -u "+%Y-%m-%dT%H:%M:%SZ")
REPO_NAME=$(basename "$TARGET_DIR")
TOOLKIT_VERSION=$(git -C "$SECURITY_REPO_DIR" describe --tags --always 2>/dev/null || echo "unknown")
TOOLKIT_COMMIT=$(git -C "$SECURITY_REPO_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")

FOUND_ISSUES=0
ACCEPTED_COUNT=0
REJECTED_COUNT=0

# Function to compute hash for a finding (used for allowlist)
hash_finding() {
    echo -n "$1" | shasum -a 256 | awk '{print $1}'
}

# Function to check if a finding is allowlisted
is_allowlisted() {
    local finding="$1"
    local hash=$(hash_finding "$finding")
    if [ -f "$ALLOWLIST_FILE" ]; then
        grep -q "^$hash" "$ALLOWLIST_FILE" 2>/dev/null && return 0
    fi
    return 1
}

# Function to add a finding to the allowlist
add_to_allowlist() {
    local finding="$1"
    local reason="$2"
    local hash=$(hash_finding "$finding")

    # Create allowlist file with header if it doesn't exist
    if [ ! -f "$ALLOWLIST_FILE" ]; then
        {
            echo "# Secrets Scan Allowlist"
            echo "# Format: SHA256_HASH # REASON # FINDING"
            echo "# Generated by Security Verification Toolkit"
            echo ""
        } > "$ALLOWLIST_FILE"
    fi

    # Add entry with hash, reason, and truncated finding for reference
    local truncated=$(echo "$finding" | cut -c1-80)
    echo "$hash # $reason # $truncated" >> "$ALLOWLIST_FILE"
}

# Function to prompt user for interactive review
prompt_review() {
    local finding="$1"
    local check_name="$2"
    local severity="$3"

    # Parse the finding to extract file, line, and content
    local file_path=$(echo "$finding" | cut -d: -f1)
    local line_num=$(echo "$finding" | cut -d: -f2)
    local content=$(echo "$finding" | cut -d: -f3-)

    # Get relative path for cleaner display
    local rel_path="${file_path#$TARGET_DIR/}"

    echo ""
    echo "  ┌─────────────────────────────────────────────────────────────────"
    echo "  │ REVIEW REQUIRED: $check_name [$severity]"
    echo "  ├─────────────────────────────────────────────────────────────────"
    echo "  │ File: $rel_path"
    echo "  │ Line: $line_num"
    echo "  │"
    echo "  │ Content:"
    echo "  │   $content"
    echo "  └─────────────────────────────────────────────────────────────────"
    echo ""

    # Provide context-aware explanation based on check type
    if echo "$check_name" | grep -q "Shell Command Injection"; then
        echo "  WHY THIS MATCHED:"
        echo "    Pattern: eval \"\$...\" detected"
        echo "    'eval' can be dangerous if used with untrusted input."
        echo "    However, 'eval' with controlled internal variables is often safe."
        echo "    Common false positives: dynamic variable assignment in scripts"
        echo ""
    else
        echo "  WHY THIS MATCHED:"
        echo "    This pattern may indicate hardcoded credentials or secrets."
        echo "    Review carefully to ensure no sensitive data is exposed."
        echo ""
    fi

    echo "  OPTIONS:"
    echo "    [A]ccept  - This is NOT a secret/vulnerability. Add to allowlist (custom reason)."
    echo "    [R]eject  - This IS a security issue. Flag for remediation."
    echo "    [S]kip    - Unsure. Leave for later review."
    echo ""
    echo "  QUICK ACCEPT (common false positives):"
    echo "    [E]xample - Example/placeholder data (example.com, test@example.org, etc.)"
    echo "    [D]ocumentation - Documentation or comments explaining patterns"
    echo "    [I]nternal - Internal/controlled variable assignment (safe eval, etc.)"
    echo "    [T]est - Test fixture or mock data"
    echo ""

    while true; do
        echo -n "  Your decision [A/R/S/E/D/I/T]: "
        read -r response < /dev/tty
        case "$response" in
            [Ee]*)
                add_to_allowlist "$finding" "Example/placeholder data (not real credentials)"
                echo "  → Added to allowlist: Example/placeholder data"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Dd]*)
                add_to_allowlist "$finding" "Documentation or pattern explanation"
                echo "  → Added to allowlist: Documentation"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Ii]*)
                add_to_allowlist "$finding" "Internal/controlled variable assignment"
                echo "  → Added to allowlist: Internal variable"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Tt]*)
                add_to_allowlist "$finding" "Test fixture or mock data"
                echo "  → Added to allowlist: Test data"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Aa]*)
                echo ""
                echo "  Why is this acceptable? (This will be recorded in the allowlist)"
                echo -n "  Reason: "
                read -r reason < /dev/tty
                if [ -z "$reason" ]; then
                    echo "  ✗ Reason is required for audit trail. Please try again."
                    continue
                fi
                add_to_allowlist "$finding" "$reason"
                echo "  → Added to allowlist"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0  # Accepted - not an issue
                ;;
            [Rr]*)
                echo "  → Flagged as security issue"
                REJECTED_COUNT=$((REJECTED_COUNT + 1))
                return 1  # Rejected - is an issue
                ;;
            [Ss]*)
                echo "  → Skipped (will require review next time)"
                return 2  # Skipped - still needs review
                ;;
            *)
                echo "  Please enter A, R, S, E, D, I, or T"
                ;;
        esac
    done
}

echo "Secrets/Vulnerability Verification Scan"
echo "========================================"
echo "Timestamp: $TIMESTAMP"
echo "Toolkit: Security Verification Toolkit $TOOLKIT_VERSION ($TOOLKIT_COMMIT)"
echo "Target: $TARGET_DIR"
echo "Repository: $REPO_NAME"
echo ""

# Function to run a check and log results
run_check() {
    local check_name="$1"
    local pattern="$2"
    local severity="$3"

    echo "Checking: $check_name [$severity]"

    # Run grep, capture output (exclude .git, binary files, scan results, and verification scripts)
    local results=""
    results=$(grep -r -n -E "$pattern" "$TARGET_DIR" \
        --include="*.sh" \
        --include="*.py" \
        --include="*.js" \
        --include="*.ts" \
        --include="*.rb" \
        --include="*.php" \
        --include="*.go" \
        --include="*.rs" \
        --include="*.java" \
        --include="*.cs" \
        --include="*.yaml" \
        --include="*.yml" \
        --include="*.json" \
        --include="*.env" \
        --include="*.conf" \
        --include="*.config" \
        --include="*.md" \
        --include="*.tex" \
        --exclude-dir=".git" \
        --exclude-dir="node_modules" \
        --exclude-dir="venv" \
        --exclude-dir=".venv" \
        --exclude-dir="__pycache__" \
        --exclude-dir=".scans" \
        --exclude-dir="obj" \
        --exclude-dir="bin" \
        --exclude-dir="publish" \
        --exclude="*Scan-Results.md" \
        --exclude="check-*.sh" \
        --exclude=".secrets-allowlist" \
        2>/dev/null || true)

    local total_count=0
    local new_count=0
    local allowlisted_count=0
    local issue_count=0

    if [ -n "$results" ]; then
        total_count=$(echo "$results" | wc -l | tr -d ' ')

        # Process each finding
        while IFS= read -r line; do
            if [ -z "$line" ]; then
                continue
            fi

            # Check if already allowlisted
            if is_allowlisted "$line"; then
                allowlisted_count=$((allowlisted_count + 1))
                continue
            fi

            new_count=$((new_count + 1))

            # Interactive mode: prompt for each finding
            if [ "$INTERACTIVE" -eq 1 ]; then
                prompt_review "$line" "$check_name" "$severity"
                local review_result=$?
                if [ $review_result -eq 1 ]; then
                    # Rejected - counts as an issue
                    issue_count=$((issue_count + 1))
                elif [ $review_result -eq 2 ]; then
                    # Skipped - still needs review
                    issue_count=$((issue_count + 1))
                fi
                # If accepted (0), not counted as issue
            else
                # Non-interactive: show findings
                if [ $new_count -le 5 ]; then
                    echo "$line"
                fi
                issue_count=$((issue_count + 1))
            fi
        done <<< "$results"
    fi

    # Report results
    if [ "$total_count" -eq 0 ]; then
        echo "  Result: PASS (0 matches)"
    elif [ "$new_count" -eq 0 ]; then
        echo "  Result: PASS ($allowlisted_count allowlisted)"
    elif [ "$INTERACTIVE" -eq 1 ]; then
        if [ "$issue_count" -eq 0 ]; then
            echo "  Result: PASS (all $new_count finding(s) accepted)"
        else
            echo "  Result: REVIEW - $issue_count unresolved finding(s)"
            FOUND_ISSUES=1
        fi
    else
        echo "  Result: REVIEW - $new_count match(es) found"
        if [ "$new_count" -gt 5 ]; then
            echo "  ... and $((new_count - 5)) more"
        fi
        if [ "$allowlisted_count" -gt 0 ]; then
            echo "  ($allowlisted_count previously allowlisted)"
        fi
        FOUND_ISSUES=1
    fi
}

# Run all vulnerability checks
run_check "AWS Access Keys" \
    "AKIA[0-9A-Z]{16}" \
    "CRITICAL"

run_check "AWS Secret Keys" \
    "['\"][A-Za-z0-9/+=]{40}['\"]" \
    "CRITICAL"

run_check "Generic API Keys" \
    "(api[_-]?key|apikey)['\"]?\s*[:=]\s*['\"][A-Za-z0-9]{16,}" \
    "HIGH"

run_check "Private Keys" \
    "-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----" \
    "CRITICAL"

run_check "Database Connection Strings" \
    "(mysql|postgres|mongodb|redis)://[^:]+:[^@]+@" \
    "CRITICAL"

run_check "Hardcoded Passwords" \
    "(password|passwd|pwd)['\"]?\s*[:=]\s*['\"][^'\"]{8,}" \
    "HIGH"

run_check "Bearer Tokens" \
    "Bearer\s+[A-Za-z0-9_-]{20,}" \
    "HIGH"

run_check "GitHub Tokens" \
    "gh[pousr]_[A-Za-z0-9_]{36,}" \
    "CRITICAL"

run_check "Slack Tokens" \
    "xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24}" \
    "HIGH"

run_check "Shell Command Injection" \
    "eval\s+\"\\\$" \
    "MEDIUM"

# Summary
echo ""
echo "========================================"

if [ "$INTERACTIVE" -eq 1 ]; then
    echo "Interactive Review Summary:"
    echo "  Accepted (allowlisted): $ACCEPTED_COUNT"
    echo "  Rejected (flagged):     $REJECTED_COUNT"
    echo ""
fi

if [ -f "$ALLOWLIST_FILE" ]; then
    ALLOWLIST_COUNT=$(grep -c "^[a-f0-9]" "$ALLOWLIST_FILE" 2>/dev/null || echo "0")
    echo "Allowlist: $ALLOWLIST_FILE ($ALLOWLIST_COUNT entries)"
    echo ""
fi

if [ $FOUND_ISSUES -eq 0 ]; then
    echo "OVERALL RESULT: PASS"
    if [ "$INTERACTIVE" -eq 1 ]; then
        echo "All findings reviewed and accepted."
    else
        echo "No secrets or vulnerabilities detected."
    fi
else
    echo "OVERALL RESULT: REVIEW REQUIRED"
    echo "Potential secrets/vulnerabilities detected. Manual review required."
    if [ "$INTERACTIVE" -eq 0 ]; then
        echo ""
        echo "Run with -i flag for interactive review:"
        echo "  $0 -i $TARGET_DIR"
    fi
fi

exit $FOUND_ISSUES
