#!/bin/bash
#
# Secrets/Vulnerability Verification Script
#
# Purpose: Automated scanning for common security vulnerabilities
# Method: Pattern matching for secrets, credentials, and security anti-patterns
#
# Checks performed:
#   - Hardcoded API keys and tokens
#   - AWS/cloud credentials
#   - Private keys
#   - Database connection strings with passwords
#   - Hardcoded passwords in code
#   - GitHub/Slack tokens
#   - Shell command injection patterns
#
# Exit codes:
#   0 = All checks passed (no vulnerabilities found, or all reviewed/accepted)
#   1 = Potential vulnerabilities detected (requires review)
#
# Usage: ./check-secrets.sh [-i] [target_directory]
#        -i  Interactive mode: prompt to accept/reject each finding
#        If no target specified, uses parent directory of script location
#
# Allowlist:
#   Accepted findings are stored in <target>/.allowlists/secrets-allowlist
#   Format: SHA256 hash of "file:line:content" per line
#   Allowlisted items are automatically skipped in future scans

set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/init.sh"

# Help function
show_help() {
    cat << 'EOF'
Usage: check-secrets.sh [OPTIONS] [TARGET_DIRECTORY]

Scan files for hardcoded secrets, credentials, and security vulnerabilities.

OPTIONS:
  -h, --help         Show this help message and exit
  -i, --interactive  Prompt to accept/reject each finding

ARGUMENTS:
  TARGET_DIRECTORY   Directory to scan (default: parent of script location)

PATTERNS DETECTED:
  - API keys              Generic API key patterns, Bearer tokens
  - AWS credentials       Access keys, secret keys
  - Private keys          RSA, SSH, PGP private key headers
  - Database strings      Connection strings with embedded passwords
  - Hardcoded passwords   password=, passwd=, pwd= assignments
  - Cloud tokens          GitHub, Slack, Stripe, etc.
  - Command injection     Dangerous shell patterns

ALLOWLIST:
  Accepted findings are stored in <target>/.allowlists/secrets-allowlist
  Each entry includes SHA256 hash and justification for audit trail.
  Allowlisted items are automatically skipped in future scans.

EXAMPLES:
  ./check-secrets.sh                    # Scan parent directory
  ./check-secrets.sh -i /path/to/code   # Interactive mode
  ./check-secrets.sh .                  # Scan current directory

EXIT CODES:
  0  No secrets found (or all findings allowlisted)
  1  Potential secrets detected

NIST CONTROL: SA-11 (Developer Testing and Evaluation)
EOF
    exit 0
}

# Parse arguments
INTERACTIVE=0
TARGET_DIR=""

while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        -i|--interactive)
            INTERACTIVE=1
            shift
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR="$SECURITY_REPO_DIR"
fi

# Allowlist file location (in .allowlists/ directory, gitignored)
ALLOWLIST_DIR="$TARGET_DIR/.allowlists"
ALLOWLIST_FILE="$ALLOWLIST_DIR/secrets-allowlist"

# Initialize toolkit (sets TIMESTAMP, TOOLKIT_VERSION, TOOLKIT_COMMIT)
init_security_toolkit
REPO_NAME=$(basename "$TARGET_DIR")

FOUND_ISSUES=0
ACCEPTED_COUNT=0
REJECTED_COUNT=0
TOTAL_FINDINGS=0

# Initialize audit logging
if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
    init_audit_log "$TARGET_DIR" "secrets-scan" || true
fi

# Function to extract just the content from a finding (strips file:line: prefix)
extract_content() {
    echo "$1" | cut -d: -f3-
}

# Function to compute hash for a finding (uses content only, not file:line)
hash_finding() {
    local content=$(extract_content "$1")
    echo -n "$content" | shasum -a 256 | awk '{print $1}'
}

# Function to check if a finding is allowlisted
is_allowlisted() {
    local finding="$1"
    local hash=$(hash_finding "$finding")
    if [ -f "$ALLOWLIST_FILE" ]; then
        grep -q "^$hash" "$ALLOWLIST_FILE" 2>/dev/null && return 0
    fi
    return 1
}

# Function to add a finding to the allowlist
add_to_allowlist() {
    local finding="$1"
    local reason="$2"
    local hash=$(hash_finding "$finding")

    # Create allowlist directory if it doesn't exist
    if [ ! -d "$ALLOWLIST_DIR" ]; then
        mkdir -p "$ALLOWLIST_DIR"
    fi

    # Create allowlist file with header if it doesn't exist
    if [ ! -f "$ALLOWLIST_FILE" ]; then
        {
            echo "# Secrets Scan Allowlist"
            echo "# Format: SHA256_HASH # REASON # FINDING"
            echo "# Generated by Security Verification Toolkit"
            echo ""
        } > "$ALLOWLIST_FILE"
    fi

    # Add entry with hash, reason, and truncated finding for reference
    local truncated=$(echo "$finding" | cut -c1-80)
    echo "$hash # $reason # $truncated" >> "$ALLOWLIST_FILE"

    # Audit log the config change
    if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
        audit_log_config_change "allowlist" "add" "hash=$hash reason=$reason"
    fi
}

# Function to prompt user for interactive review
prompt_review() {
    local finding="$1"
    local check_name="$2"
    local severity="$3"

    # Parse the finding to extract file, line, and content
    local file_path=$(echo "$finding" | cut -d: -f1)
    local line_num=$(echo "$finding" | cut -d: -f2)
    local content=$(echo "$finding" | cut -d: -f3-)

    # Get relative path for cleaner display
    local rel_path="${file_path#$TARGET_DIR/}"

    echo ""
    echo "  ┌─────────────────────────────────────────────────────────────────"
    echo "  │ REVIEW REQUIRED: $check_name [$severity]"
    echo "  ├─────────────────────────────────────────────────────────────────"
    echo "  │ File: $rel_path"
    echo "  │ Line: $line_num"
    echo "  │"
    echo "  │ Content:"
    echo "  │   $content"
    echo "  └─────────────────────────────────────────────────────────────────"
    echo ""

    # Provide context-aware explanation based on check type
    if echo "$check_name" | grep -q "Shell Command Injection"; then
        echo "  WHY THIS MATCHED:"
        echo "    Pattern: eval \"\$...\" detected"
        echo "    'eval' can be dangerous if used with untrusted input."
        echo "    However, 'eval' with controlled internal variables is often safe."
        echo "    Common false positives: dynamic variable assignment in scripts"
        echo ""
    else
        echo "  WHY THIS MATCHED:"
        echo "    This pattern may indicate hardcoded credentials or secrets."
        echo "    Review carefully to ensure no sensitive data is exposed."
        echo ""
    fi

    echo "  OPTIONS:"
    echo "    [A]ccept  - This is NOT a secret/vulnerability. Add to allowlist (custom reason)."
    echo "    [R]eject  - This IS a security issue. Flag for remediation."
    echo "    [S]kip    - Unsure. Leave for later review."
    echo ""
    echo "  QUICK ACCEPT (common false positives):"
    echo "    [E]xample - Example/placeholder data (example.com, test@example.org, etc.)"
    echo "    [D]ocumentation - Documentation or comments explaining patterns"
    echo "    [I]nternal - Internal/controlled variable assignment (safe eval, etc.)"
    echo "    [T]est - Test fixture or mock data"
    echo ""

    while true; do
        echo -n "  Your decision [A/R/S/E/D/I/T]: "
        read -r response < /dev/tty
        case "$response" in
            [Ee]*)
                add_to_allowlist "$finding" "Example/placeholder data (not real credentials)"
                echo "  → Added to allowlist: Example/placeholder data"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Dd]*)
                add_to_allowlist "$finding" "Documentation or pattern explanation"
                echo "  → Added to allowlist: Documentation"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Ii]*)
                add_to_allowlist "$finding" "Internal/controlled variable assignment"
                echo "  → Added to allowlist: Internal variable"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Tt]*)
                add_to_allowlist "$finding" "Test fixture or mock data"
                echo "  → Added to allowlist: Test data"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0
                ;;
            [Aa]*)
                echo ""
                echo "  Why is this acceptable? (This will be recorded in the allowlist)"
                echo -n "  Reason: "
                read -r reason < /dev/tty
                if [ -z "$reason" ]; then
                    echo "  ✗ Reason is required for audit trail. Please try again."
                    continue
                fi
                add_to_allowlist "$finding" "$reason"
                echo "  → Added to allowlist"
                ACCEPTED_COUNT=$((ACCEPTED_COUNT + 1))
                return 0  # Accepted - not an issue
                ;;
            [Rr]*)
                echo "  → Flagged as security issue"
                REJECTED_COUNT=$((REJECTED_COUNT + 1))
                return 1  # Rejected - is an issue
                ;;
            [Ss]*)
                echo "  → Skipped (will require review next time)"
                return 2  # Skipped - still needs review
                ;;
            *)
                echo "  Please enter A, R, S, E, D, I, or T"
                ;;
        esac
    done
}

echo "Secrets/Vulnerability Verification Scan"
echo "========================================"
echo "Timestamp: $TIMESTAMP"
echo "Toolkit: Security Verification Toolkit $TOOLKIT_VERSION ($TOOLKIT_COMMIT)"
echo "Target: $TARGET_DIR"
echo "Repository: $REPO_NAME"
echo ""

# Determine timeout command (GNU coreutils timeout may be gtimeout on macOS)
if command -v timeout &>/dev/null; then
    TIMEOUT_CMD="timeout 1"
elif command -v gtimeout &>/dev/null; then
    TIMEOUT_CMD="gtimeout 1"
else
    # No timeout available - run without it (slightly less protection against symlink attacks)
    TIMEOUT_CMD=""
fi

# Function to run a check and log results
run_check() {
    local check_name="$1"
    local pattern="$2"
    local severity="$3"

    echo "Checking: $check_name [$severity]"

    # Run grep, capture output (exclude .git, binary files, scan results, and verification scripts)
    # CRITICAL-003: Protection against symlink attacks - use find to exclude symlinks, add per-file timeout
    local results=""
    results=$(find "$TARGET_DIR" \
        -type f \
        -not -type l \
        -not -path "*/.git/*" \
        -not -path "*/node_modules/*" \
        -not -path "*/venv/*" \
        -not -path "*/.venv/*" \
        -not -path "*/__pycache__/*" \
        -not -path "*/.scans/*" \
        -not -path "*/obj/*" \
        -not -path "*/bin/*" \
        -not -path "*/publish/*" \
        -not -name "*Scan-Results.md" \
        -not -name "check-*.sh" \
        -not -name ".secrets-allowlist" \
        \( -name "*.sh" -o -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.rb" -o -name "*.php" \
            -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.cs" \
            -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \
            -o -name "*.env" -o -name "*.conf" -o -name "*.config" -o -name "*.md" -o -name "*.tex" \) \
        2>/dev/null | while read -r file; do
        $TIMEOUT_CMD grep -H -n -E "$pattern" "$file" 2>/dev/null || true
    done || true)

    local total_count=0
    local new_count=0
    local allowlisted_count=0
    local issue_count=0

    if [ -n "$results" ]; then
        total_count=$(echo "$results" | wc -l | tr -d ' ')

        # Process each finding
        while IFS= read -r line; do
            if [ -z "$line" ]; then
                continue
            fi

            # Check if already allowlisted
            if is_allowlisted "$line"; then
                allowlisted_count=$((allowlisted_count + 1))
                # Audit log allowlist match
                if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
                    local hash=$(hash_finding "$line")
                    audit_log_allowlist_match "$check_name" "$line" "$hash"
                fi
                continue
            fi

            new_count=$((new_count + 1))
            TOTAL_FINDINGS=$((TOTAL_FINDINGS + 1))

            # Audit log the finding
            if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
                audit_log_finding "$check_name" "$line" "severity=$severity"
            fi

            # Interactive mode: prompt for each finding
            if [ "$INTERACTIVE" -eq 1 ]; then
                prompt_review "$line" "$check_name" "$severity"
                local review_result=$?
                if [ $review_result -eq 1 ]; then
                    # Rejected - counts as an issue
                    issue_count=$((issue_count + 1))
                elif [ $review_result -eq 2 ]; then
                    # Skipped - still needs review
                    issue_count=$((issue_count + 1))
                fi
                # If accepted (0), not counted as issue
            else
                # Non-interactive: show findings
                if [ $new_count -le 5 ]; then
                    echo "$line"
                fi
                issue_count=$((issue_count + 1))
            fi
        done <<< "$results"
    fi

    # Report results
    if [ "$total_count" -eq 0 ]; then
        echo "  Result: PASS (0 matches)"
    elif [ "$new_count" -eq 0 ]; then
        echo "  Result: PASS ($allowlisted_count allowlisted)"
    elif [ "$INTERACTIVE" -eq 1 ]; then
        if [ "$issue_count" -eq 0 ]; then
            echo "  Result: PASS (all $new_count finding(s) accepted)"
        else
            echo "  Result: REVIEW - $issue_count unresolved finding(s)"
            FOUND_ISSUES=1
        fi
    else
        echo "  Result: REVIEW - $new_count match(es) found"
        if [ "$new_count" -gt 5 ]; then
            echo "  ... and $((new_count - 5)) more"
        fi
        if [ "$allowlisted_count" -gt 0 ]; then
            echo "  ($allowlisted_count previously allowlisted)"
        fi
        FOUND_ISSUES=1
    fi
}

# Run all vulnerability checks
run_check "AWS Access Keys" \
    "AKIA[0-9A-Z]{16}" \
    "CRITICAL"

run_check "AWS Secret Keys" \
    "['\"][A-Za-z0-9/+=]{40}['\"]" \
    "CRITICAL"

run_check "Generic API Keys" \
    "(api[_-]?key|apikey)['\"]?\s*[:=]\s*['\"][A-Za-z0-9]{16,}" \
    "HIGH"

run_check "Private Keys" \
    "-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----" \
    "CRITICAL"

run_check "Database Connection Strings" \
    "(mysql|postgres|mongodb|redis)://[^:]+:[^@]+@" \
    "CRITICAL"

run_check "Hardcoded Passwords" \
    "(password|passwd|pwd)['\"]?\s*[:=]\s*['\"][^'\"]{8,}" \
    "HIGH"

run_check "Bearer Tokens" \
    "Bearer\s+[A-Za-z0-9_-]{20,}" \
    "HIGH"

run_check "GitHub Tokens" \
    "gh[pousr]_[A-Za-z0-9_]{36,}" \
    "CRITICAL"

run_check "Slack Tokens" \
    "xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24}" \
    "HIGH"

run_check "Shell Command Injection" \
    "eval\s+\"\\\$" \
    "MEDIUM"

# Summary
echo ""
echo "========================================"

if [ "$INTERACTIVE" -eq 1 ]; then
    echo "Interactive Review Summary:"
    echo "  Accepted (allowlisted): $ACCEPTED_COUNT"
    echo "  Rejected (flagged):     $REJECTED_COUNT"
    echo ""
fi

if [ -f "$ALLOWLIST_FILE" ]; then
    ALLOWLIST_COUNT=$(grep -c "^[a-f0-9]" "$ALLOWLIST_FILE" 2>/dev/null || echo "0")
    echo "Allowlist: $ALLOWLIST_FILE ($ALLOWLIST_COUNT entries)"
    echo ""
fi

if [ $FOUND_ISSUES -eq 0 ]; then
    echo "OVERALL RESULT: PASS"
    if [ "$INTERACTIVE" -eq 1 ]; then
        echo "All findings reviewed and accepted."
    else
        echo "No secrets or vulnerabilities detected."
    fi
    # Finalize audit log with PASS status
    if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
        finalize_audit_log "PASS" "findings=$TOTAL_FINDINGS"
    fi
else
    echo "OVERALL RESULT: REVIEW REQUIRED"
    echo "Potential secrets/vulnerabilities detected. Manual review required."
    if [ "$INTERACTIVE" -eq 0 ]; then
        echo ""
        echo "Run with -i flag for interactive review:"
        echo "  $0 -i $TARGET_DIR"
    fi
    # Finalize audit log with FAIL status
    if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
        finalize_audit_log "FAIL" "findings=$TOTAL_FINDINGS"
    fi
fi

exit $FOUND_ISSUES
