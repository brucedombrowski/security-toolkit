#!/bin/bash
#
# Malware Verification Script
#
# Purpose: Automated scanning of repository files for malware using ClamAV
# Method: ClamAV virus scanner with verbose output and file hash generation
#
# Exit codes:
#   0 = Scan passed (no malware found)
#   1 = Malware detected or scan error
#
# Usage: ./check-malware.sh [target_directory]
#        If no target specified, uses parent directory of script location
#
# Output:
#   - Verbose scan results with file-by-file status
#   - JSON metadata with MD5/SHA1/SHA256 hashes saved to .scans/malware-metadata/
#   - Native ClamAV log file saved to .scans/

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECURITY_REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Allow target directory to be specified as argument
if [ -n "$1" ]; then
    TARGET_DIR="$1"
else
    TARGET_DIR="$SECURITY_REPO_DIR"
fi

TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
DATE_STAMP=$(date "+%Y-%m-%d")
REPO_NAME=$(basename "$TARGET_DIR")
TOOLKIT_VERSION=$(git -C "$SECURITY_REPO_DIR" describe --tags --always 2>/dev/null || echo "unknown")
TOOLKIT_COMMIT=$(git -C "$SECURITY_REPO_DIR" rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Check for clamscan
CLAMSCAN="/opt/homebrew/bin/clamscan"
if [ ! -x "$CLAMSCAN" ]; then
    CLAMSCAN=$(which clamscan 2>/dev/null || echo "")
fi

if [ -z "$CLAMSCAN" ] || [ ! -x "$CLAMSCAN" ]; then
    echo "ERROR: ClamAV (clamscan) not found"
    echo "Install with: brew install clamav"
    exit 1
fi

# Check for freshclam
FRESHCLAM="/opt/homebrew/bin/freshclam"
if [ ! -x "$FRESHCLAM" ]; then
    FRESHCLAM=$(which freshclam 2>/dev/null || echo "")
fi

# Check for sigtool (for database info)
SIGTOOL="/opt/homebrew/bin/sigtool"
if [ ! -x "$SIGTOOL" ]; then
    SIGTOOL=$(which sigtool 2>/dev/null || echo "")
fi

# Find ClamAV database directory
# Check for main.cvd as the indicator (or daily.cvd/cld as backup)
DB_DIR=""
for dir in /opt/homebrew/var/lib/clamav /var/lib/clamav /usr/local/var/lib/clamav; do
    if [ -d "$dir" ]; then
        if [ -f "$dir/main.cvd" ] || [ -f "$dir/daily.cvd" ] || [ -f "$dir/daily.cld" ]; then
            DB_DIR="$dir"
            break
        fi
    fi
done

# Attempt to update virus database
if [ -n "$FRESHCLAM" ] && [ -x "$FRESHCLAM" ]; then
    echo "Attempting to update ClamAV virus database..."
    UPDATE_EXIT=0
    # Check for freshclam.conf
    FRESHCLAM_CONF=""
    for conf in /opt/homebrew/etc/clamav/freshclam.conf /etc/clamav/freshclam.conf /usr/local/etc/clamav/freshclam.conf; do
        if [ -f "$conf" ]; then
            FRESHCLAM_CONF="$conf"
            break
        fi
    done

    if [ -n "$FRESHCLAM_CONF" ]; then
        UPDATE_OUTPUT=$($FRESHCLAM --config-file="$FRESHCLAM_CONF" 2>&1) || UPDATE_EXIT=$?
    else
        UPDATE_OUTPUT=$($FRESHCLAM 2>&1) || UPDATE_EXIT=$?
    fi

    if [ $UPDATE_EXIT -eq 0 ]; then
        echo "  Database update: SUCCESS"
    elif echo "$UPDATE_OUTPUT" | grep -qi "up.to.date" ; then
        echo "  Database update: Already up to date"
    elif echo "$UPDATE_OUTPUT" | grep -qi "bytecode.cvd is up to date" ; then
        echo "  Database update: Already up to date"
    else
        echo "  Database update: SKIPPED (exit code: $UPDATE_EXIT)"
        if echo "$UPDATE_OUTPUT" | grep -qi "config" ; then
            echo "  Note: freshclam config file may need setup"
            echo "  Copy sample: cp /opt/homebrew/etc/clamav/freshclam.conf.sample /opt/homebrew/etc/clamav/freshclam.conf"
        else
            echo "  Run 'sudo freshclam' manually if needed"
        fi
    fi
    echo ""
else
    echo "Note: freshclam not found, skipping database update"
    echo "Install with: brew install clamav"
    echo ""
fi

# Get ClamAV version (includes database date in format: ClamAV X.X.X/DBVER/DATE)
CLAMAV_VERSION=$($CLAMSCAN --version 2>/dev/null | head -1)

# Extract and display detailed database information
# Supports both .cvd (full) and .cld (incremental/local) database formats
get_db_info() {
    local db_base="$1"
    local db_name="$2"
    local db_file=""
    local db_format=""

    # Check for .cvd (full database) or .cld (local/incremental database)
    if [ -f "${db_base}.cvd" ]; then
        db_file="${db_base}.cvd"
        db_format="cvd"
    elif [ -f "${db_base}.cld" ]; then
        db_file="${db_base}.cld"
        db_format="cld"
    fi

    if [ -n "$SIGTOOL" ] && [ -x "$SIGTOOL" ] && [ -n "$db_file" ]; then
        local info_output=$($SIGTOOL --info "$db_file" 2>/dev/null)
        local build_time=$(echo "$info_output" | grep "Build time:" | sed 's/Build time: //')
        local version=$(echo "$info_output" | grep "Version:" | sed 's/Version: //')
        local sigs=$(echo "$info_output" | grep "Signatures:" | sed 's/Signatures: //')
        if [ -n "$build_time" ]; then
            if [ "$db_format" = "cld" ]; then
                echo "  $db_name: Version $version, Built $build_time ($sigs signatures) [incremental]"
            else
                echo "  $db_name: Version $version, Built $build_time ($sigs signatures)"
            fi
        fi
    fi
}

# Create output directories
# Use temp directory for metadata during scan to avoid scanning our own output
SCANS_DIR="$TARGET_DIR/.scans"
TEMP_METADATA_DIR=$(mktemp -d)
METADATA_DIR="$SCANS_DIR/malware-metadata-$DATE_STAMP"
CLAMAV_LOG_TEMP=$(mktemp)

# Will move to final location after scan
mkdir -p "$SCANS_DIR"

echo "Malware Verification Scan"
echo "========================="
echo "Timestamp: $TIMESTAMP"
echo "Toolkit: Security Verification Toolkit $TOOLKIT_VERSION ($TOOLKIT_COMMIT)"
echo "Source: https://github.com/brucedombrowski/Security"
echo "Scanner: $CLAMAV_VERSION"
echo "Target: $TARGET_DIR"
echo "Repository: $REPO_NAME"
echo ""
echo "Virus Database Information:"
if [ -n "$DB_DIR" ]; then
    echo "  Database Location: $DB_DIR"
    get_db_info "$DB_DIR/main" "Main DB"
    get_db_info "$DB_DIR/daily" "Daily DB"
    get_db_info "$DB_DIR/bytecode" "Bytecode DB"
else
    echo "  Database location: Unknown (using ClamAV default)"
fi
echo ""

# Run verbose scan with JSON metadata generation
# Options:
#   --recursive: Scan subdirectories
#   --verbose: Show file-by-file results
#   --gen-json: Generate JSON metadata for each file
#   --leave-temps: Keep JSON files in temp directory
#   --json-store-extra-hashes: Include MD5, SHA1, SHA256 in JSON
#   --tempdir: Store JSON metadata in our output directory
#   --log: Save native ClamAV log

echo "Running ClamAV scan with verbose output and hash generation..."
echo ""

# Capture scan output
# Exclude .scans directory to avoid recursive scanning of our own output
SCAN_EXIT_CODE=0
$CLAMSCAN \
    --recursive \
    --verbose \
    --gen-json \
    --leave-temps \
    --json-store-extra-hashes \
    --tempdir="$TEMP_METADATA_DIR" \
    --log="$CLAMAV_LOG_TEMP" \
    --exclude-dir="\.scans" \
    --exclude-dir="\.git" \
    "$TARGET_DIR" 2>&1 || SCAN_EXIT_CODE=$?

# Move temp files to final location
mv "$TEMP_METADATA_DIR" "$METADATA_DIR"
mv "$CLAMAV_LOG_TEMP" "$SCANS_DIR/clamav-log-$DATE_STAMP.txt"
CLAMAV_LOG="$SCANS_DIR/clamav-log-$DATE_STAMP.txt"

echo ""

# Count infected files from log
INFECTED_COUNT=$(grep -c "FOUND$" "$CLAMAV_LOG" 2>/dev/null || true)
if [ -z "$INFECTED_COUNT" ]; then
    INFECTED_COUNT=0
fi

# Extract and display file hashes from JSON metadata
JSON_COUNT=$(find "$METADATA_DIR" -name "metadata.json" 2>/dev/null | wc -l | tr -d ' ')
if [ "$JSON_COUNT" -gt 0 ] || [ -d "$METADATA_DIR" ]; then
    # Count actual JSON directories (each scanned file gets a directory)
    DIR_COUNT=$(find "$METADATA_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
    if [ "$DIR_COUNT" -gt 0 ]; then
        echo "File Hash Manifest:"
        echo "-------------------"
        # Extract hashes from JSON files and format as manifest
        find "$METADATA_DIR" -mindepth 1 -maxdepth 1 -type d -exec sh -c '
            for dir; do
                json_file=$(find "$dir" -name "*.json" -o -name "clamav-*.tmp" 2>/dev/null | head -1)
                if [ -f "$dir/metadata.json" ]; then
                    json_file="$dir/metadata.json"
                elif [ -n "$json_file" ]; then
                    :
                else
                    # Try to find any file that looks like JSON
                    for f in "$dir"/*; do
                        if [ -f "$f" ] && head -1 "$f" 2>/dev/null | grep -q "CLAMJSONv0"; then
                            json_file="$f"
                            break
                        fi
                    done
                fi
                if [ -n "$json_file" ] && [ -f "$json_file" ]; then
                    # Extract fields using grep/sed (portable, no jq dependency)
                    filename=$(grep -o "\"FileName\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FileName\":\"\([^\"]*\)\".*/\1/")
                    filepath=$(grep -o "\"FilePath\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FilePath\":\"\([^\"]*\)\".*/\1/")
                    sha256=$(grep -o "\"sha2-256\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"sha2-256\":\"\([^\"]*\)\".*/\1/")
                    md5=$(grep -o "\"md5\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"md5\":\"\([^\"]*\)\".*/\1/")
                    sha1=$(grep -o "\"sha1\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"sha1\":\"\([^\"]*\)\".*/\1/")
                    filesize=$(grep -o "\"FileSize\":[0-9]*" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FileSize\":\([0-9]*\).*/\1/")
                    # Only show actual source files, not internal metadata or PDF objects
                    if [ -n "$filename" ] && [ -n "$sha256" ]; then
                        # Skip metadata.json, clamav temp files, and PDF internal objects
                        case "$filename" in
                            metadata.json|clamav-*|"pdf obj"*) continue ;;
                        esac
                        # Skip files from .scans directory
                        case "$filepath" in
                            */.scans/*) continue ;;
                        esac
                        echo "  $filename"
                        echo "    SHA256: $sha256"
                        echo "    MD5:    $md5"
                        echo "    SHA1:   $sha1"
                        echo "    Size:   $filesize bytes"
                    fi
                fi
            done
        ' _ {} +
        echo ""
    fi
fi

echo "========================="
echo ""
echo "Scan Artifacts:"
echo "  ClamAV Log: $CLAMAV_LOG"
echo "  JSON Metadata: $METADATA_DIR/"
echo ""
echo "========================="

if [ "$INFECTED_COUNT" -eq 0 ] && [ "$SCAN_EXIT_CODE" -eq 0 ]; then
    echo "RESULT: PASS"
    echo "No malware detected."
    EXIT_CODE=0
else
    echo "RESULT: FAIL"
    if [ "$INFECTED_COUNT" -gt 0 ]; then
        echo "$INFECTED_COUNT infected file(s) detected!"
        echo ""
        echo "Infected files:"
        grep "FOUND$" "$CLAMAV_LOG" 2>/dev/null || true
    else
        echo "Scan completed with errors (exit code: $SCAN_EXIT_CODE)"
    fi
    EXIT_CODE=1
fi

exit $EXIT_CODE
