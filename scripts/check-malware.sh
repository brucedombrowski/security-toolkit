#!/bin/bash
#
# Malware Verification Script
#
# Purpose: Automated scanning of repository files for malware using ClamAV
# Method: ClamAV virus scanner with verbose output and file hash generation
#
# Exit codes:
#   0 = Scan passed (no malware found)
#   1 = Malware detected or scan error
#   2 = Missing required dependencies (ClamAV not installed)
#
# Usage: ./check-malware.sh [OPTIONS] [target_directory]
#        If no target specified, uses parent directory of script location
#
# Options:
#   --full-system    Scan common user directories (~/*, /Applications, /tmp)
#   --system-root    Scan entire filesystem from / (VERY slow, use with caution)
#   -h, --help       Show this help message
#
# Output:
#   - Verbose scan results with file-by-file status
#   - JSON metadata with MD5/SHA1/SHA256 hashes saved to .scans/malware-metadata/
#   - Native ClamAV log file saved to .scans/

set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/init.sh"

# ============================================================================
# ARGUMENT PARSING
# ============================================================================
FULL_SYSTEM_SCAN=false
SYSTEM_ROOT_SCAN=false
POSITIONAL_ARGS=()

show_help() {
    cat << 'HELP'
Malware Verification Script

Usage: ./check-malware.sh [OPTIONS] [target_directory]

Options:
  --full-system    Scan common user directories:
                   - Home directory (~/)
                   - Applications (/Applications on macOS)
                   - Temp files (/tmp)
                   - Downloads (~/Downloads)
                   Recommended for thorough user-space malware check.

  --system-root    Scan entire filesystem from /
                   WARNING: Very slow, may take hours. Use with caution.
                   Excludes: /System, /dev, /proc, /sys (protected/virtual)

  -h, --help       Show this help message

Examples:
  ./check-malware.sh                     # Scan toolkit directory
  ./check-malware.sh /path/to/project    # Scan specific directory
  ./check-malware.sh --full-system       # Scan user directories
  ./check-malware.sh --system-root       # Scan entire system (slow!)

Exit codes:
  0 = Scan passed (no malware found)
  1 = Malware detected or scan error
  2 = Missing required dependencies
HELP
    exit 0
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --full-system)
            FULL_SYSTEM_SCAN=true
            shift
            ;;
        --system-root)
            SYSTEM_ROOT_SCAN=true
            shift
            ;;
        -h|--help)
            show_help
            ;;
        -*)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

# Restore positional arguments
set -- "${POSITIONAL_ARGS[@]:-}"

# Determine target directory based on options
if [ "$SYSTEM_ROOT_SCAN" = true ]; then
    TARGET_DIR="/"
    echo "WARNING: Full system scan from / - this may take a very long time!"
    echo ""
elif [ "$FULL_SYSTEM_SCAN" = true ]; then
    # Will scan multiple directories - set TARGET_DIR to home for output location
    TARGET_DIR="$HOME"
    SCAN_DIRS=("$HOME")
    [ -d "/Applications" ] && SCAN_DIRS+=("/Applications")
    [ -d "/tmp" ] && SCAN_DIRS+=("/tmp")
    echo "Full system scan mode - scanning user directories:"
    for dir in "${SCAN_DIRS[@]}"; do
        echo "  - $dir"
    done
    echo ""
elif [ -n "${1:-}" ]; then
    TARGET_DIR="$1"
else
    TARGET_DIR="$SECURITY_REPO_DIR"
fi

# Initialize toolkit (sets TIMESTAMP, TOOLKIT_VERSION, TOOLKIT_COMMIT)
init_security_toolkit
if [ "$TIMESTAMPS_AVAILABLE" -eq 1 ]; then
    DATE_STAMP=$(get_date_stamp)
else
    DATE_STAMP=$(date -u "+%Y-%m-%d")
fi
REPO_NAME=$(basename "$TARGET_DIR")

# ============================================================================
# CLAMAV PATH RESOLUTION
# ClamAV can be found in multiple locations:
#   1. Bundled with toolkit (for airgapped systems): $SCRIPT_DIR/../clamav/
#   2. System PATH (most portable)
#   3. Homebrew paths (macOS)
#   4. Linux standard paths
# We check bundled first (for airgapped), then system, then known locations.
# ============================================================================
CLAMSCAN=""
BUNDLED_CLAMAV=""
BUNDLED_DB=""

# Helper to find bundled ClamAV
find_bundled_clamav() {
    local toolkit_dir="$SCRIPT_DIR/.."
    local clamav_dir="$toolkit_dir/clamav"

    # Check for bundled ClamAV directory
    if [ -d "$clamav_dir" ]; then
        local clamscan_bin=""
        # Check for platform-appropriate binary
        if [ -x "$clamav_dir/clamscan" ]; then
            clamscan_bin="$clamav_dir/clamscan"
        elif [ -x "$clamav_dir/clamscan.exe" ]; then
            clamscan_bin="$clamav_dir/clamscan.exe"
        fi

        if [ -n "$clamscan_bin" ]; then
            # Check for bundled database
            if [ -d "$clamav_dir/db" ] && [ -f "$clamav_dir/db/main.cvd" ]; then
                BUNDLED_CLAMAV="$clamscan_bin"
                BUNDLED_DB="$clamav_dir/db"
                return 0
            fi
        fi
    fi
    return 1
}

# 1. Check for bundled ClamAV first (airgapped systems)
if find_bundled_clamav; then
    CLAMSCAN="$BUNDLED_CLAMAV"
    echo "Using bundled ClamAV: $CLAMSCAN"
    echo "Using bundled database: $BUNDLED_DB"
# 2. Try standard $PATH (most portable)
elif command -v clamscan &>/dev/null; then
    CLAMSCAN=$(which clamscan 2>/dev/null)
# 3. Check Homebrew ARM64 path (macOS Apple Silicon)
elif [ -x "/opt/homebrew/bin/clamscan" ]; then
    CLAMSCAN="/opt/homebrew/bin/clamscan"
# 4. Check Homebrew Intel path (older macOS)
elif [ -x "/usr/local/bin/clamscan" ]; then
    CLAMSCAN="/usr/local/bin/clamscan"
# 5. Check Linux standard path
elif [ -x "/usr/bin/clamscan" ]; then
    CLAMSCAN="/usr/bin/clamscan"
fi

if [ -z "$CLAMSCAN" ] || [ ! -x "$CLAMSCAN" ]; then
    echo "SKIPPED: ClamAV (clamscan) not found"
    echo ""
    echo "Options to install ClamAV:"
    echo "  - macOS:   brew install clamav"
    echo "  - Linux:   apt install clamav (Debian/Ubuntu) or yum install clamav (RHEL/CentOS)"
    echo "  - Windows: Download from https://www.clamav.net/downloads"
    echo "  - Airgapped: Download platform-specific release with bundled ClamAV"
    echo ""
    echo "Malware Verification Scan"
    echo "========================="
    echo "Status: SKIPPED (dependency missing)"
    echo "Reason: ClamAV not installed"
    echo ""
    echo "OVERALL RESULT: SKIP"
    exit 2
fi

# Check Docker daemon status (informational - not required for ClamAV)
# Docker can be used for containerized scanning in some workflows
check_docker_status() {
    if command -v docker &>/dev/null; then
        # Docker CLI is installed, check if daemon is running
        if ! docker info &>/dev/null 2>&1; then
            echo "WARNING: Docker is installed but the Docker daemon is not running."
            echo "  Some advanced scanning features may require Docker."
            echo "  To start Docker:"
            echo "    - macOS: Open Docker Desktop application"
            echo "    - Linux: sudo systemctl start docker"
            echo ""

            # Give user a chance to start Docker if running fully interactively
            # Only prompt if BOTH stdin and stdout are terminals (not redirected)
            if [ -t 0 ] && [ -t 1 ]; then
                read -t 10 -p "Press Enter to continue without Docker (auto-continues in 10s)... " -r || true
                echo ""
                # Check again after user had a chance to start it
                if docker info &>/dev/null 2>&1; then
                    echo "Docker daemon is now running."
                    echo ""
                fi
            fi
        fi
    fi
}

# Run Docker check (non-blocking, informational only)
check_docker_status

# Check for freshclam (bundled or system)
FRESHCLAM=""
if [ -n "$BUNDLED_CLAMAV" ]; then
    # Check for bundled freshclam alongside clamscan
    BUNDLED_BIN_DIR=$(dirname "$BUNDLED_CLAMAV")
    if [ -x "$BUNDLED_BIN_DIR/freshclam" ]; then
        FRESHCLAM="$BUNDLED_BIN_DIR/freshclam"
    elif [ -x "$BUNDLED_BIN_DIR/freshclam.exe" ]; then
        FRESHCLAM="$BUNDLED_BIN_DIR/freshclam.exe"
    fi
fi
if [ -z "$FRESHCLAM" ] || [ ! -x "$FRESHCLAM" ]; then
    if [ -x "/opt/homebrew/bin/freshclam" ]; then
        FRESHCLAM="/opt/homebrew/bin/freshclam"
    else
        FRESHCLAM=$(which freshclam 2>/dev/null || echo "")
    fi
fi

# Check for sigtool (for database info) - bundled or system
SIGTOOL=""
if [ -n "$BUNDLED_CLAMAV" ]; then
    if [ -x "$BUNDLED_BIN_DIR/sigtool" ]; then
        SIGTOOL="$BUNDLED_BIN_DIR/sigtool"
    elif [ -x "$BUNDLED_BIN_DIR/sigtool.exe" ]; then
        SIGTOOL="$BUNDLED_BIN_DIR/sigtool.exe"
    fi
fi
if [ -z "$SIGTOOL" ] || [ ! -x "$SIGTOOL" ]; then
    if [ -x "/opt/homebrew/bin/sigtool" ]; then
        SIGTOOL="/opt/homebrew/bin/sigtool"
    else
        SIGTOOL=$(which sigtool 2>/dev/null || echo "")
    fi
fi

# Find ClamAV database directory
# Priority: bundled DB > system DB locations
DB_DIR=""
if [ -n "$BUNDLED_DB" ] && [ -d "$BUNDLED_DB" ]; then
    DB_DIR="$BUNDLED_DB"
else
    # Check for main.cvd as the indicator (or daily.cvd/cld as backup)
    for dir in /opt/homebrew/var/lib/clamav /var/lib/clamav /usr/local/var/lib/clamav; do
        if [ -d "$dir" ]; then
            if [ -f "$dir/main.cvd" ] || [ -f "$dir/daily.cvd" ] || [ -f "$dir/daily.cld" ]; then
                DB_DIR="$dir"
                break
            fi
        fi
    done
fi

# Attempt to update virus database (skip for bundled/airgapped systems)
if [ -n "$BUNDLED_DB" ]; then
    echo "Note: Using bundled virus definitions (airgapped mode)"
    echo "  To update definitions, use: ./scripts/update-clamav-offline.sh --apply <update-file>"
    echo ""
elif [ -n "$FRESHCLAM" ] && [ -x "$FRESHCLAM" ]; then
    echo "Attempting to update ClamAV virus database..."
    UPDATE_EXIT=0
    # Check for freshclam.conf
    FRESHCLAM_CONF=""
    for conf in /opt/homebrew/etc/clamav/freshclam.conf /etc/clamav/freshclam.conf /usr/local/etc/clamav/freshclam.conf; do
        if [ -f "$conf" ]; then
            FRESHCLAM_CONF="$conf"
            break
        fi
    done

    if [ -n "$FRESHCLAM_CONF" ]; then
        UPDATE_OUTPUT=$($FRESHCLAM --config-file="$FRESHCLAM_CONF" 2>&1) || UPDATE_EXIT=$?
    else
        UPDATE_OUTPUT=$($FRESHCLAM 2>&1) || UPDATE_EXIT=$?
    fi

    if [ $UPDATE_EXIT -eq 0 ]; then
        echo "  Database update: SUCCESS"
    elif echo "$UPDATE_OUTPUT" | grep -qi "up.to.date" ; then
        echo "  Database update: Already up to date"
    elif echo "$UPDATE_OUTPUT" | grep -qi "bytecode.cvd is up to date" ; then
        echo "  Database update: Already up to date"
    else
        echo "  Database update: SKIPPED (exit code: $UPDATE_EXIT)"
        if echo "$UPDATE_OUTPUT" | grep -qi "config" ; then
            echo "  Note: freshclam config file may need setup"
            echo "  Copy sample: cp /opt/homebrew/etc/clamav/freshclam.conf.sample /opt/homebrew/etc/clamav/freshclam.conf"
        else
            echo "  Run 'sudo freshclam' manually if needed"
        fi
    fi
    echo ""
else
    echo "Note: freshclam not found, skipping database update"
    echo "Install with: brew install clamav"
    echo ""
fi

# Get ClamAV version (includes database date in format: ClamAV X.X.X/DBVER/DATE)
CLAMAV_VERSION=$($CLAMSCAN --version 2>/dev/null | head -1)

# Extract and display detailed database information
# Supports both .cvd (full) and .cld (incremental/local) database formats
get_db_info() {
    local db_base="$1"
    local db_name="$2"
    local db_file=""
    local db_format=""

    # Check for .cvd (full database) or .cld (local/incremental database)
    if [ -f "${db_base}.cvd" ]; then
        db_file="${db_base}.cvd"
        db_format="cvd"
    elif [ -f "${db_base}.cld" ]; then
        db_file="${db_base}.cld"
        db_format="cld"
    fi

    if [ -n "$SIGTOOL" ] && [ -x "$SIGTOOL" ] && [ -n "$db_file" ]; then
        local info_output
        # Capture sigtool output with error handling
        if info_output=$($SIGTOOL --info "$db_file" 2>/dev/null); then
            local build_time
            local version
            local sigs
            
            # Parse with validation - extract values carefully
            build_time=$(echo "$info_output" | grep "Build time:" | sed 's/Build time: //' | head -1)
            version=$(echo "$info_output" | grep "Version:" | sed 's/Version: //' | head -1)
            sigs=$(echo "$info_output" | grep "Signatures:" | sed 's/Signatures: //' | head -1)
            
            # Only display if we successfully parsed the key fields
            if [ -n "$build_time" ] && [ -n "$version" ]; then
                if [ "$db_format" = "cld" ]; then
                    echo "  $db_name: Version $version, Built $build_time${sigs:+ ($sigs signatures)} [incremental]"
                else
                    echo "  $db_name: Version $version, Built $build_time${sigs:+ ($sigs signatures)}"
                fi
            else
                # Gracefully handle unparseable format (ClamAV version changed)
                echo "  $db_name: $db_format database present (version info unavailable)"
            fi
        else
            # sigtool failed - database may be corrupted or tool not working
            echo "  $db_name: $db_format database present (could not read metadata)"
        fi
    elif [ -n "$db_file" ]; then
        # sigtool not available - just report file exists
        echo "  $db_name: $db_format database present"
    fi
}

# Create output directories
# Use temp directory for metadata during scan to avoid scanning our own output
SCANS_DIR="$TARGET_DIR/.scans"
TEMP_METADATA_DIR=$(mktemp -d)
METADATA_DIR="$SCANS_DIR/malware-metadata-$DATE_STAMP"
CLAMAV_LOG_TEMP=$(mktemp)

# Will move to final location after scan
mkdir -p "$SCANS_DIR"

# Initialize audit logging
if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
    init_audit_log "$TARGET_DIR" "malware-scan" || true
fi

echo "Malware Verification Scan"
echo "========================="
echo "Timestamp: $TIMESTAMP"
echo "Toolkit: $TOOLKIT_NAME $TOOLKIT_VERSION ($TOOLKIT_COMMIT)"
echo "Source: $TOOLKIT_SOURCE"
echo "Scanner: $CLAMAV_VERSION"
echo "Target: $TARGET_DIR"
echo "Repository: $REPO_NAME"
echo ""
echo "Virus Database Information:"
if [ -n "$DB_DIR" ]; then
    echo "  Database Location: $DB_DIR"
    get_db_info "$DB_DIR/main" "Main DB"
    get_db_info "$DB_DIR/daily" "Daily DB"
    get_db_info "$DB_DIR/bytecode" "Bytecode DB"
else
    echo "  Database location: Unknown (using ClamAV default)"
fi
echo ""

# Run verbose scan with JSON metadata generation
# Options:
#   --recursive: Scan subdirectories
#   --verbose: Show file-by-file results
#   --gen-json: Generate JSON metadata for each file
#   --leave-temps: Keep JSON files in temp directory
#   --json-store-extra-hashes: Include MD5, SHA1, SHA256 in JSON
#   --tempdir: Store JSON metadata in our output directory
#   --log: Save native ClamAV log

echo "Running ClamAV scan with verbose output and hash generation..."
echo "Note: Symlink protection enabled - common symlink targets are excluded"
echo ""

# Start progress tracking for scan
if [ "$PROGRESS_AVAILABLE" -eq 1 ]; then
    progress_start
    spinner_start "Scanning for malware"
fi

# Capture scan output
# CRITICAL-003: Protection against symlink attacks - exclude common symlink targets
SCAN_EXIT_CODE=0

# Detect ClamAV feature support
# Different ClamAV versions support different options:
#   --gen-json: added in ClamAV 0.100
#   --json-store-extra-hashes: added later, not in all versions
CLAM_HELP=$($CLAMSCAN --help 2>&1)
CLAM_JSON_SUPPORT=false
CLAM_EXTRA_HASHES=false
if echo "$CLAM_HELP" | grep -q "gen-json"; then
    CLAM_JSON_SUPPORT=true
fi
if echo "$CLAM_HELP" | grep -q "json-store-extra-hashes"; then
    CLAM_EXTRA_HASHES=true
fi

# Build clamscan arguments based on detected features
CLAM_ARGS=(
    --recursive
    --verbose
    --log="$CLAMAV_LOG_TEMP"
    --exclude-dir="\.scans"
    --exclude-dir="\.git"
    --exclude-dir="node_modules"
    --exclude-dir="venv"
    --exclude-dir="__pycache__"
)

# Add JSON metadata options if supported
if [ "$CLAM_JSON_SUPPORT" = true ]; then
    CLAM_ARGS+=(--gen-json --leave-temps --tempdir="$TEMP_METADATA_DIR")
    if [ "$CLAM_EXTRA_HASHES" = true ]; then
        CLAM_ARGS+=(--json-store-extra-hashes)
    fi
fi

# Use bundled database if available (for airgapped systems)
if [ -n "$BUNDLED_DB" ] && [ -d "$BUNDLED_DB" ]; then
    CLAM_ARGS+=(--database="$BUNDLED_DB")
    echo "Note: Using bundled virus definitions"
    if [ -f "$BUNDLED_DB/downloaded.txt" ]; then
        echo "  Database date: $(cat "$BUNDLED_DB/downloaded.txt")"
    fi
    echo ""
fi

# Add system-level exclusions for full system scans
if [ "$SYSTEM_ROOT_SCAN" = true ]; then
    CLAM_ARGS+=(
        --exclude-dir="^/System"
        --exclude-dir="^/dev"
        --exclude-dir="^/proc"
        --exclude-dir="^/sys"
        --exclude-dir="^/private/var/vm"
    )
fi

# Run scan on target(s)
if [ "$FULL_SYSTEM_SCAN" = true ] && [ ${#SCAN_DIRS[@]} -gt 0 ]; then
    # Scan multiple directories
    $CLAMSCAN "${CLAM_ARGS[@]}" "${SCAN_DIRS[@]}" 2>&1 || SCAN_EXIT_CODE=$?
else
    # Scan single target directory
    $CLAMSCAN "${CLAM_ARGS[@]}" "$TARGET_DIR" 2>&1 || SCAN_EXIT_CODE=$?
fi

# Stop spinner
if [ "$PROGRESS_AVAILABLE" -eq 1 ]; then
    spinner_stop "complete"
fi

# Move temp files to final location
mv "$CLAMAV_LOG_TEMP" "$SCANS_DIR/clamav-log-$DATE_STAMP.txt"
CLAMAV_LOG="$SCANS_DIR/clamav-log-$DATE_STAMP.txt"

# Only move metadata dir if JSON was enabled
if [ "$CLAM_JSON_SUPPORT" = true ]; then
    mv "$TEMP_METADATA_DIR" "$METADATA_DIR"
else
    rm -rf "$TEMP_METADATA_DIR"
    mkdir -p "$METADATA_DIR"  # Create empty dir for consistency
fi

echo ""

# Count infected files from log
INFECTED_COUNT=$(grep -c "FOUND$" "$CLAMAV_LOG" 2>/dev/null || true)
if [ -z "$INFECTED_COUNT" ]; then
    INFECTED_COUNT=0
fi

# Extract and display file hashes from JSON metadata (only if JSON supported)
if [ "$CLAM_JSON_SUPPORT" = false ]; then
    echo "Note: JSON metadata not available (ClamAV version doesn't support --gen-json)"
    echo ""
fi
JSON_COUNT=$(find "$METADATA_DIR" -name "metadata.json" 2>/dev/null | wc -l | tr -d ' ')
if [ "$CLAM_JSON_SUPPORT" = true ] && { [ "$JSON_COUNT" -gt 0 ] || [ -d "$METADATA_DIR" ]; }; then
    # Count actual JSON directories (each scanned file gets a directory)
    DIR_COUNT=$(find "$METADATA_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
    if [ "$DIR_COUNT" -gt 0 ]; then
        echo "File Hash Manifest:"
        echo "-------------------"
        # Extract hashes from JSON files and format as manifest
        find "$METADATA_DIR" -mindepth 1 -maxdepth 1 -type d -exec sh -c '
            for dir; do
                json_file=$(find "$dir" -name "*.json" -o -name "clamav-*.tmp" 2>/dev/null | head -1)
                if [ -f "$dir/metadata.json" ]; then
                    json_file="$dir/metadata.json"
                elif [ -n "$json_file" ]; then
                    :
                else
                    # Try to find any file that looks like JSON
                    for f in "$dir"/*; do
                        if [ -f "$f" ] && head -1 "$f" 2>/dev/null | grep -q "CLAMJSONv0"; then
                            json_file="$f"
                            break
                        fi
                    done
                fi
                if [ -n "$json_file" ] && [ -f "$json_file" ]; then
                    # Extract fields using grep/sed (portable, no jq dependency)
                    filename=$(grep -o "\"FileName\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FileName\":\"\([^\"]*\)\".*/\1/")
                    filepath=$(grep -o "\"FilePath\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FilePath\":\"\([^\"]*\)\".*/\1/")
                    sha256=$(grep -o "\"sha2-256\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"sha2-256\":\"\([^\"]*\)\".*/\1/")
                    md5=$(grep -o "\"md5\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"md5\":\"\([^\"]*\)\".*/\1/")
                    sha1=$(grep -o "\"sha1\":\"[^\"]*\"" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"sha1\":\"\([^\"]*\)\".*/\1/")
                    filesize=$(grep -o "\"FileSize\":[0-9]*" "$json_file" 2>/dev/null | head -1 | sed "s/.*\"FileSize\":\([0-9]*\).*/\1/")
                    # Only show actual source files, not internal metadata or PDF objects
                    if [ -n "$filename" ] && [ -n "$sha256" ]; then
                        # Skip metadata.json, clamav temp files, and PDF internal objects
                        case "$filename" in
                            metadata.json|clamav-*|"pdf obj"*) continue ;;
                        esac
                        # Skip files from .scans directory
                        case "$filepath" in
                            */.scans/*) continue ;;
                        esac
                        echo "  $filename"
                        echo "    SHA256: $sha256"
                        echo "    MD5:    $md5"
                        echo "    SHA1:   $sha1"
                        echo "    Size:   $filesize bytes"
                    fi
                fi
            done
        ' _ {} +
        echo ""
    fi
fi

echo "========================="
echo ""
echo "Scan Artifacts:"
echo "  ClamAV Log: $CLAMAV_LOG"
echo "  JSON Metadata: $METADATA_DIR/"
echo ""
echo "========================="

if [ "$INFECTED_COUNT" -eq 0 ] && [ "$SCAN_EXIT_CODE" -eq 0 ]; then
    echo "RESULT: PASS"
    echo "No malware detected."
    EXIT_CODE=0
    # Finalize audit log with PASS status
    if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
        finalize_audit_log "PASS" "infected=0"
    fi
else
    echo "RESULT: FAIL"
    if [ "$INFECTED_COUNT" -gt 0 ]; then
        echo "$INFECTED_COUNT infected file(s) detected!"
        echo ""
        echo "Infected files:"
        # Log each infected file to audit log
        while IFS= read -r infected_line; do
            if [ -n "$infected_line" ] && [ "$AUDIT_AVAILABLE" -eq 1 ]; then
                audit_log_finding "MALWARE" "$infected_line" "scanner=ClamAV"
            fi
            echo "$infected_line"
        done < <(grep "FOUND$" "$CLAMAV_LOG" 2>/dev/null || true)
    else
        echo "Scan completed with errors (exit code: $SCAN_EXIT_CODE)"
        if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
            audit_log_error "Scan error" "exit_code=$SCAN_EXIT_CODE"
        fi
    fi
    EXIT_CODE=1
    # Finalize audit log with FAIL status
    if [ "$AUDIT_AVAILABLE" -eq 1 ]; then
        finalize_audit_log "FAIL" "infected=$INFECTED_COUNT"
    fi
fi

exit $EXIT_CODE
